<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <title>注音麥塊小遊戲（Blockly + Three.js）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Tailwind（純排版） -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- Blockly -->
  <script src="https://unpkg.com/blockly@9.3.3/blockly_compressed.js"></script>
  <script src="https://unpkg.com/blockly@9.3.3/blocks_compressed.js"></script>
  <script src="https://unpkg.com/blockly@9.3.3/javascript_compressed.js"></script>
  <script src="https://unpkg.com/blockly@9.3.3/msg/zh-hant.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: "Microsoft JhengHei", "Noto Sans TC", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    #blocklyDiv {
      width: 100%;
      height: 100%;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      outline: none;
    }

    /* Blockly 外觀微調 */
    .blocklyToolboxDiv {
      background-color: #f1f5f9 !important;
      border-bottom: 1px solid #cbd5f5 !important;
      box-sizing: border-box;
    }
    .blocklySvg {
      background-color: #ffffff !important;
    }
    .blocklyMainBackground {
      stroke: none !important;
    }
  </style>
</head>
<body class="bg-slate-900 text-white">
  <div class="flex h-screen">
    <!-- 左側：Blockly 控制區 -->
    <div class="w-full md:w-1/3 min-w-[320px] bg-slate-100 text-slate-900 flex flex-col border-r border-slate-700">
      <div class="px-4 py-2 border-b border-slate-300 bg-slate-50 flex items-center justify-between">
        <div class="font-semibold text-slate-700">程式積木</div>
        <div class="text-xs text-slate-500">拖曳積木來控制麥塊人物</div>
      </div>
      <div class="flex-1 relative">
        <div id="blocklyDiv" class="absolute inset-0"></div>
      </div>
      <div class="px-4 py-3 border-t border-slate-300 bg-slate-50 flex gap-2">
        <button id="runBtn"
                class="px-4 py-2 rounded-md bg-emerald-600 text-white text-sm font-semibold hover:bg-emerald-700 transition">
          ▶ 執行程式
        </button>
        <button id="resetBtn"
                class="px-4 py-2 rounded-md bg-slate-600 text-white text-sm hover:bg-slate-700 transition">
          ⟳ 重設人物
        </button>
      </div>
    </div>

    <!-- 右側：Three.js 場景 -->
    <div class="flex-1 relative">
      <canvas id="gameCanvas"></canvas>

      <!-- 注音與國字資訊 + 關卡切換 + 編輯 -->
      <div id="info"
           class="absolute top-3 left-3 bg-black/60 text-xs md:text-sm px-3 py-2 rounded-md pointer-events-auto z-10">
        <div class="space-y-1">
          <div id="wordInfo">國字：</div>
          <div id="zhuyinInfo">注音：</div>
          <div id="collectedInfo">目前收集：尚未收集</div>
        </div>

        <div class="flex items-center gap-2 pt-1 mt-2 border-t border-white/20">
          <button id="prevLevelBtn"
                  class="px-2 py-1 rounded bg-white/10 text-[11px] md:text-xs hover:bg-white/20 disabled:opacity-40 disabled:hover:bg-white/10">
            ◀ 上一關
          </button>
          <div id="levelInfo" class="text-[11px] md:text-xs">
            第 1 關 / 共 1 關
          </div>
          <button id="nextLevelBtn"
                  class="px-2 py-1 rounded bg-white/10 text-[11px] md:text-xs hover:bg-white/20 disabled:opacity-40 disabled:hover:bg-white/10">
            下一關 ▶
          </button>
        </div>

        <!-- 編輯關卡面板 -->
        <details class="mt-2 bg-black/40 rounded px-2 py-1 text-[11px] md:text-xs">
          <summary class="cursor-pointer select-none">
            編輯關卡
          </summary>
          <div class="mt-2 space-y-1">
            <div class="flex items-center gap-1">
              <span class="shrink-0">國字</span>
              <input id="cfgWordInput"
                     class="w-24 px-1 py-0.5 rounded bg-white/90 text-slate-900 text-[11px] outline-none" />
            </div>
            <div class="flex items-center gap-1">
              <span class="shrink-0">注音</span>
              <input id="cfgZhuyinInput"
                     placeholder="例：ㄕ ㄨ ㄣ ˋ"
                     class="w-36 px-1 py-0.5 rounded bg-white/90 text-slate-900 text-[11px] outline-none" />
            </div>
            <div class="flex gap-1 pt-1">
              <button id="cfgApplyCurrent"
                      class="flex-1 px-1 py-0.5 rounded bg-emerald-500 text-white text-[11px] hover:bg-emerald-600">
                更新本關
              </button>
              <button id="cfgAddLevel"
                      class="flex-1 px-1 py-0.5 rounded bg-sky-500 text-white text-[11px] hover:bg-sky-600">
                新增關卡
              </button>
            </div>
            <div class="text-[10px] text-white/70 pt-1">
              注音符號請用空格分開，最多 4 個。
            </div>
          </div>
        </details>
      </div>

      <!-- 狀態提示 -->
      <div id="status"
           class="absolute bottom-3 left-3 bg-black/60 text-xs md:text-sm px-3 py-2 rounded-md pointer-events-none z-10">
        提示：在左邊組程式，再按「執行程式」。
      </div>

      <!-- 收集完成對話框 -->
      <div id="completeDialog"
           class="hidden fixed inset-0 flex items-center justify-center bg-black/60 z-20">
        <div class="bg-white text-slate-900 rounded-xl shadow-xl px-6 py-4 w-80 max-w-[90vw] text-center">
          <div id="dialogTitle" class="text-lg font-semibold mb-2">太棒了！</div>
          <div id="dialogMessage" class="text-sm mb-4">
            你完成了關卡。
          </div>
          <div class="flex justify-center gap-3">
            <button id="dialogRestartBtn"
                    class="px-4 py-2 rounded-md bg-slate-600 text-white text-sm font-semibold hover:bg-slate-700">
              重玩本關
            </button>
            <button id="dialogNextBtn"
                    class="px-4 py-2 rounded-md bg-emerald-600 text-white text-sm font-semibold hover:bg-emerald-700">
              下一關
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========= 教師預設關卡（載入時用這些當起點） =========
    let levelInputConfig = [
      { word: "順", zhuyin: "ㄕ ㄨ ㄣ ˋ" },
      { word: "媽", zhuyin: "ㄇ ㄚ ˊ" },
      { word: "家", zhuyin: "ㄐ ㄧ ㄚ" }
    ];

    // ========= 基本常數與隨機工具 =========
    const GRID_SIZE = 9;
    const GRID_OFFSET = Math.floor(GRID_SIZE / 2);

    const DIR_ROTATIONS = [
      Math.PI,        // 0: 面向 -z
      Math.PI / 2,    // 1: 面向 +x
      0,              // 2: 面向 +z（朝玩家）
      -Math.PI / 2    // 3: 面向 -x
    ];

    const MAX_ITEMS_PER_LEVEL = 4;

    // 從整個地圖挑隨機格子（排除 bannedSet 裡的 x,z）
    function getRandomGridPositions(count, bannedSet) {
      const positions = [];
      for (let z = 0; z < GRID_SIZE; z++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const key = x + "," + z;
          if (bannedSet && bannedSet.has(key)) continue;
          positions.push({ x, z });
        }
      }
      if (positions.length <= count) return positions;

      for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = positions[i];
        positions[i] = positions[j];
        positions[j] = tmp;
      }
      return positions.slice(0, count);
    }

    // ========= 建立 LEVELS 結構 =========
    function buildLevelsFromInput(configList) {
      const levels = [];

      configList.forEach((cfg, idx) => {
        if (!cfg) return;
        const word = cfg.word || ("第" + (idx + 1) + "關");
        const zhuyinArr = String(cfg.zhuyin || "")
          .split(/\s+/)
          .map(s => s.trim())
          .filter(Boolean);

        if (!zhuyinArr.length) return;

        const usedZhuyin = zhuyinArr.slice(0, MAX_ITEMS_PER_LEVEL);

        const map = Array.from({ length: GRID_SIZE }, () =>
          Array(GRID_SIZE).fill(1)
        );
        const itemMapping = {};

        const banned = new Set();
        // 不要放在起始點
        banned.add("4,4");

        const positions = getRandomGridPositions(usedZhuyin.length, banned);
        positions.forEach((pos, i) => {
          const sym = usedZhuyin[i];
          const code = 10 + i;
          map[pos.z][pos.x] = code;
          itemMapping[code] = sym;
        });

        levels.push({
          targetChar: word,
          targetZhuyin: usedZhuyin,
          map,
          itemMapping,
          start: { x: 4, z: 4, dir: 2 } // 一開始面向 +z（朝玩家）
        });
      });

      // 保底：若真的沒設定到，就塞一關預設
      if (!levels.length) {
        const map = Array.from({ length: GRID_SIZE }, () =>
          Array(GRID_SIZE).fill(1)
        );
        const itemMapping = {};
        const defaultZhuyin = ["ㄕ", "ㄨ", "ㄣ", "ˋ"];

        const banned = new Set();
        banned.add("4,4");
        const positions = getRandomGridPositions(defaultZhuyin.length, banned);

        positions.forEach((pos, i) => {
          const sym = defaultZhuyin[i];
          const code = 10 + i;
          map[pos.z][pos.x] = code;
          itemMapping[code] = sym;
        });

        levels.push({
          targetChar: "順",
          targetZhuyin: defaultZhuyin,
          map,
          itemMapping,
          start: { x: 4, z: 4, dir: 2 }
        });
      }

      return levels;
    }

    let LEVELS = buildLevelsFromInput(levelInputConfig);
    let currentLevelIndex = 0;

    // ========= 全域變數 =========
    let workspace = null;

    let scene = null;
    let camera = null;
    let renderer = null;
    let levelGroup = null;

    let player = null;
    let playerLimbs = {};

    let tiles = [];
    let items = [];
    let extraPlayers = [];
    let collectedSymbols = [];

    const playerState = { x: 0, z: 0, dir: 0 };

    // ========= UI 小工具 =========
    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    function updateStatus(text) {
      const el = document.getElementById('status');
      if (el) el.textContent = text;
    }

    function updateCollectedInfo() {
      const el = document.getElementById('collectedInfo');
      if (!el) return;
      if (collectedSymbols.length === 0) {
        el.textContent = "目前收集：尚未收集";
      } else {
        el.textContent = "目前收集：" + collectedSymbols.join(" ");
      }
    }

    function updateLevelNavButtons() {
      const prevBtn = document.getElementById('prevLevelBtn');
      const nextBtn = document.getElementById('nextLevelBtn');
      if (prevBtn) prevBtn.disabled = (currentLevelIndex === 0);
      if (nextBtn) nextBtn.disabled = (currentLevelIndex === LEVELS.length - 1);
    }

    function fillLevelFormFromConfig() {
      const wordInput = document.getElementById('cfgWordInput');
      const zhuyinInput = document.getElementById('cfgZhuyinInput');
      if (!wordInput || !zhuyinInput) return;
      const cfg = levelInputConfig[currentLevelIndex];
      if (!cfg) {
        wordInput.value = "";
        zhuyinInput.value = "";
      } else {
        wordInput.value = cfg.word || "";
        zhuyinInput.value = cfg.zhuyin || "";
      }
    }

    function updateLevelInfo() {
      const level = LEVELS[currentLevelIndex];
      const wEl = document.getElementById('wordInfo');
      const zEl = document.getElementById('zhuyinInfo');
      const lEl = document.getElementById('levelInfo');

      if (level) {
        if (wEl) wEl.textContent = "國字：" + (level.targetChar || "");
        if (zEl) zEl.textContent = "注音：" + level.targetZhuyin.join(" ");
      }
      if (lEl) {
        lEl.textContent =
          "第 " + (currentLevelIndex + 1) + " 關 / 共 " + LEVELS.length + " 關";
      }
      updateCollectedInfo();
      updateLevelNavButtons();
      fillLevelFormFromConfig();
    }

    function showCompleteDialog(level) {
      const dialog = document.getElementById('completeDialog');
      const msgEl  = document.getElementById('dialogMessage');
      const nextBtn = document.getElementById('dialogNextBtn');

      if (level && msgEl) {
        msgEl.textContent =
          "你用 " + level.targetZhuyin.join(" ") +
          " 組成了「" + level.targetChar + "」！";
      }

      if (nextBtn) {
        if (currentLevelIndex === LEVELS.length - 1) {
          nextBtn.textContent = "關閉";
        } else {
          nextBtn.textContent = "下一關";
        }
      }

      if (dialog) dialog.classList.remove('hidden');
    }

    function hideCompleteDialog() {
      const dialog = document.getElementById('completeDialog');
      if (dialog) dialog.classList.add('hidden');
    }

    function setLevel(index) {
      if (index < 0 || index >= LEVELS.length) return;
      currentLevelIndex = index;
      buildLevel(currentLevelIndex);
      hideCompleteDialog();
      updateLevelInfo();
      updateStatus("已切換到第 " + (currentLevelIndex + 1) + " 關。");
    }

    function rebuildLevelsAndStay(targetIndex) {
      const oldIndex = (typeof targetIndex === "number") ? targetIndex : currentLevelIndex;
      LEVELS = buildLevelsFromInput(levelInputConfig);
      let newIndex = oldIndex;
      if (newIndex < 0) newIndex = 0;
      if (newIndex >= LEVELS.length) newIndex = LEVELS.length - 1;
      currentLevelIndex = newIndex;
      buildLevel(currentLevelIndex);
      hideCompleteDialog();
      updateLevelInfo();
      updateStatus("關卡設定已更新。");
    }

    // ========= Blockly 設定 =========
    function defineBlocks() {
      Blockly.Blocks['mc_move'] = {
        init: function () {
          this.appendDummyInput().appendField("前進一格");
          this.setPreviousStatement(true, null);
          this.setNextStatement(true, null);
          this.setColour(200);
        }
      };
      Blockly.JavaScript['mc_move'] = function (block) {
        return 'commands.push("MOVE");\n';
      };

      Blockly.Blocks['mc_turn_left'] = {
        init: function () {
          this.appendDummyInput().appendField("向左轉");
          this.setPreviousStatement(true, null);
          this.setNextStatement(true, null);
          this.setColour(180);
        }
      };
      Blockly.JavaScript['mc_turn_left'] = function (block) {
        return 'commands.push("LEFT");\n';
      };

      Blockly.Blocks['mc_turn_right'] = {
        init: function () {
          this.appendDummyInput().appendField("向右轉");
          this.setPreviousStatement(true, null);
          this.setNextStatement(true, null);
          this.setColour(180);
        }
      };
      Blockly.JavaScript['mc_turn_right'] = function (block) {
        return 'commands.push("RIGHT");\n';
      };
    }

    function initBlockly() {
      defineBlocks();

      const toolbox = `
        <xml xmlns="https://developers.google.com/blockly/xml">
          <block type="mc_move"></block>
          <block type="mc_turn_left"></block>
          <block type="mc_turn_right"></block>
          <block type="controls_repeat_ext">
            <value name="TIMES">
              <shadow type="math_number">
                <field name="NUM">4</field>
              </shadow>
            </value>
          </block>
        </xml>
      `;

      workspace = Blockly.inject('blocklyDiv', {
        toolbox: toolbox,
        scrollbars: true,
        trashcan: true,
        horizontalLayout: true,
        toolboxPosition: 'top',
        zoom: {
          startScale: 1.0,
          maxScale: 2.5,
          minScale: 0.5,
          scaleSpeed: 1.2
        }
      });

      window.addEventListener('resize', function () {
        if (workspace) {
          Blockly.svgResize(workspace);
        }
      });
    }

    // ========= 基本方塊產生器 =========
    function createVoxel(color, x, y, z, sx, sy, sz) {
      const geometry = new THREE.BoxGeometry(sx, sy, sz);
      const material = new THREE.MeshStandardMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    // ========= 主角：Steve =========
    function createSteve() {
      const steveGroup = new THREE.Group();
      const skin = 0xCF9E7A;
      const hair = 0x3A2208;

      // 頭
      const head = new THREE.Group();
      head.position.y = 1.5;
      head.add(createVoxel(skin, 0, 0, 0, 0.4, 0.4, 0.4));
      head.add(createVoxel(hair, 0, 0.21, 0, 0.42, 0.05, 0.42));
      head.add(createVoxel(hair, 0, 0.1, -0.21, 0.42, 0.2, 0.05));
      head.add(createVoxel(hair, -0.21, 0.1, 0, 0.05, 0.2, 0.4));
      head.add(createVoxel(hair, 0.21, 0.1, 0, 0.05, 0.2, 0.4));

      const fz = 0.205;
      head.add(createVoxel(0xFFFFFF,  0.1,  0.05, fz,         0.1, 0.05, 0.02));
      head.add(createVoxel(0x2222FF,  0.12, 0.05, fz + 0.001, 0.05, 0.05, 0.02));
      head.add(createVoxel(0xFFFFFF, -0.1,  0.05, fz,         0.1, 0.05, 0.02));
      head.add(createVoxel(0x2222FF, -0.12, 0.05, fz + 0.001, 0.05, 0.05, 0.02));
      head.add(createVoxel(0xB87E6A, 0, -0.05, fz, 0.08, 0.05, 0.02));
      head.add(createVoxel(0x9E6A4A, 0, -0.12, fz, 0.2,  0.06, 0.02));

      steveGroup.add(head);

      // 身體
      steveGroup.add(createVoxel(0x009999, 0, 0.9, 0, 0.4, 0.6, 0.2));

      // 四肢
      const limbs = {};

      function mkLimb(x, y, color, w, h, d, isLeg) {
        const g = new THREE.Group();
        g.position.set(x, y, 0);
        g.add(createVoxel(color, 0, -h / 2 + (isLeg ? 0 : 0.1), 0, w, h, d));
        steveGroup.add(g);
        return g;
      }

      limbs.armL = mkLimb(-0.3, 1.1, skin,     0.18, 0.6, 0.18, false);
      limbs.armR = mkLimb( 0.3, 1.1, skin,     0.18, 0.6, 0.18, false);
      limbs.legL = mkLimb(-0.1, 0.6, 0x0000AA, 0.18, 0.6, 0.18, true);
      limbs.legR = mkLimb( 0.1, 0.6, 0x0000AA, 0.18, 0.6, 0.18, true);

      return { group: steveGroup, limbs: limbs };
    }

    // ========= NPC：苦力怕、乳牛、小羊 =========
    function createCreeper() {
      const group = new THREE.Group();
      const green = 0x3ba635;

      // 身體
      group.add(createVoxel(green, 0, 0.9, 0, 0.5, 1.0, 0.4));
      // 頭
      group.add(createVoxel(green, 0, 1.6, 0, 0.5, 0.5, 0.5));
      // 腿
      const legHeight = 0.3;
      const legY = 0.15;
      const legs = [
        [-0.15, legY, -0.12],
        [ 0.15, legY, -0.12],
        [-0.15, legY,  0.12],
        [ 0.15, legY,  0.12]
      ];
      legs.forEach(([x, y, z]) => {
        group.add(createVoxel(green, x, y, z, 0.18, legHeight, 0.18));
      });
      return group;
    }

    function createCow() {
      const group = new THREE.Group();
      const bodyColor = 0x8b4513;
      const spotColor = 0xffffff;
      const legColor = 0x4b3621;

      // 身體
      group.add(createVoxel(bodyColor, 0, 0.7, 0, 0.9, 0.5, 0.5));
      // 斑點
      group.add(createVoxel(spotColor, 0.15, 0.8, 0.26, 0.2, 0.2, 0.05));
      group.add(createVoxel(spotColor, -0.25, 0.6, -0.26, 0.25, 0.15, 0.05));
      // 頭
      group.add(createVoxel(bodyColor, 0, 1.0, 0.4, 0.4, 0.4, 0.4));
      // 腿
      const legH = 0.4;
      const legY = 0.2;
      const legs = [
        [-0.3, legY, -0.18],
        [ 0.3, legY, -0.18],
        [-0.3, legY,  0.18],
        [ 0.3, legY,  0.18]
      ];
      legs.forEach(([x, y, z]) => {
        group.add(createVoxel(legColor, x, y, z, 0.18, legH, 0.18));
      });
      return group;
    }

    function createSheep() {
      const group = new THREE.Group();
      const wool = 0xffffff;
      const face = 0xd8c0a8;
      const legColor = 0x777777;

      // 身體
      group.add(createVoxel(wool, 0, 0.8, 0, 0.9, 0.6, 0.5));
      // 頭
      group.add(createVoxel(face, 0, 0.85, 0.45, 0.4, 0.4, 0.4));
      // 腿
      const legH = 0.35;
      const legY = 0.175;
      const legs = [
        [-0.3, legY, -0.18],
        [ 0.3, legY, -0.18],
        [-0.3, legY,  0.18],
        [ 0.3, legY,  0.18]
      ];
      legs.forEach(([x, y, z]) => {
        group.add(createVoxel(legColor, x, y, z, 0.18, legH, 0.18));
      });
      return group;
    }

    // ========= 主角動作 =========
    function setIdlePose() {
      if (!playerLimbs.armL) return;
      playerLimbs.armL.rotation.x = 0;
      playerLimbs.armR.rotation.x = 0;
      playerLimbs.legL.rotation.x = 0;
      playerLimbs.legR.rotation.x = 0;
    }

    function updateWalkAnimation(progress) {
      if (!playerLimbs.armL) return;
      const swing = Math.sin(progress * Math.PI) * 0.7;
      playerLimbs.armL.rotation.x =  swing;
      playerLimbs.armR.rotation.x = -swing;
      playerLimbs.legL.rotation.x = -swing;
      playerLimbs.legR.rotation.x =  swing;
    }

    function updatePlayerTransform() {
      if (!player) return;
      const worldX = playerState.x - GRID_OFFSET;
      const worldZ = playerState.z - GRID_OFFSET;
      player.position.set(worldX, 0, worldZ);
      player.rotation.y = DIR_ROTATIONS[playerState.dir];
    }

    function resetPlayer() {
      const level = LEVELS[currentLevelIndex];
      playerState.x = level.start.x;
      playerState.z = level.start.z;
      playerState.dir = level.start.dir;

      collectedSymbols = [];
      items.forEach(item => {
        item.collected = false;
        item.mesh.visible = true;
      });

      updatePlayerTransform();
      setIdlePose();
      hideCompleteDialog();
      updateCollectedInfo();
    }

    // ========= 注音字卡（平面避免硬邊）與收集判定 =========
    function createZhuyinCard(char) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, 256, 256);

      ctx.font = 'bold 210px "Microsoft JhengHei", "Noto Sans TC", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // 外圈淡藍光暈，柔化邊緣
      ctx.lineWidth = 18;
      ctx.strokeStyle = 'rgba(0,255,255,0.7)';
      ctx.strokeText(char, 128, 140);

      // 主字
      ctx.lineWidth = 10;
      ctx.strokeStyle = '#FFFFFF';
      ctx.strokeText(char, 128, 140);
      ctx.fillStyle = '#00FFFF';
      ctx.fillText(char, 128, 140);

      const texture = new THREE.CanvasTexture(canvas);
      if (renderer) {
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      }
      texture.needsUpdate = true;

      // 改用「平面」，就不會有厚度邊線
      const geometry = new THREE.PlaneGeometry(1.3, 1.3);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });

      const mesh = new THREE.Mesh(geometry, material);
      return mesh;
    }

    function checkPickup() {
      const level = LEVELS[currentLevelIndex];
      if (!level) return;

      for (const item of items) {
        if (!item.collected &&
            item.gridX === playerState.x &&
            item.gridZ === playerState.z) {

          if (collectedSymbols.length >= level.targetZhuyin.length) {
            updateStatus("你已經收集完所有注音了，可以重設或切換關卡。");
            return;
          }

          const expected = level.targetZhuyin[collectedSymbols.length];
          if (item.symbol === expected) {
            item.collected = true;
            item.mesh.visible = false;
            collectedSymbols.push(item.symbol);
            updateCollectedInfo();
            updateStatus("收集到：「" + item.symbol + "」，目前：" + collectedSymbols.join(" "));

            if (collectedSymbols.length === level.targetZhuyin.length) {
              updateStatus("太棒了！你用 " +
                level.targetZhuyin.join(" ") +
                " 組成了「" + level.targetChar + "」。");
              showCompleteDialog(level);
            }
          } else {
            updateStatus("順序錯誤！應先收集「" +
              expected + "」，但你踩到「" + item.symbol + "」。");
          }
          break;
        }
      }
    }

    // ========= 移動與轉向動畫 =========
    async function animateMove() {
      const dirVecs = [
        { dx: 0, dz: -1 },
        { dx: 1, dz:  0 },
        { dx: 0, dz:  1 },
        { dx: -1,dz:  0 }
      ];
      const v = dirVecs[playerState.dir];
      const nx = playerState.x + v.dx;
      const nz = playerState.z + v.dz;

      if (nx < 0 || nx >= GRID_SIZE || nz < 0 || nz >= GRID_SIZE) {
        updateStatus("撞到邊界了，不能再前進！");
        return;
      }

      const startX = player.position.x;
      const startZ = player.position.z;
      const endX   = startX + v.dx;
      const endZ   = startZ + v.dz;

      const duration = 280;
      const steps = 14;

      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        player.position.x = startX + (endX - startX) * t;
        player.position.z = startZ + (endZ - startZ) * t;
        updateWalkAnimation(t);
        await delay(duration / steps);
      }

      playerState.x = nx;
      playerState.z = nz;
      updatePlayerTransform();
      setIdlePose();
      checkPickup();
    }

    async function animateTurn(deltaDir) {
      const oldDir = playerState.dir;
      const newDir = (playerState.dir + deltaDir + 4) % 4;
      const startRot = DIR_ROTATIONS[oldDir];
      const endRot   = DIR_ROTATIONS[newDir];

      const duration = 200;
      const steps = 12;

      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const angle = startRot + (endRot - startRot) * t;
        player.rotation.y = angle;
        await delay(duration / steps);
      }

      playerState.dir = newDir;
      updatePlayerTransform();
      setIdlePose();
    }

    // ========= Three.js 場景與關卡建立 =========
    function initThree() {
      const canvas = document.getElementById('gameCanvas');
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.shadowMap.enabled = true;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      const width = canvas.clientWidth || canvas.offsetWidth || 800;
      const height = canvas.clientHeight || canvas.offsetHeight || 600;
      camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
      camera.position.set(0, 8, 10);
      camera.lookAt(0, 0, 0);
      renderer.setSize(width, height, false);

      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 7);
      dirLight.castShadow = true;
      scene.add(dirLight);

      buildLevel(currentLevelIndex);
      animate();

      window.addEventListener('resize', function () {
        resizeRenderer();
      });
    }

    function buildLevel(levelIndex) {
      const level = LEVELS[levelIndex];
      if (!level || !scene) return;

      if (levelGroup) {
        scene.remove(levelGroup);
      }
      levelGroup = new THREE.Group();
      scene.add(levelGroup);

      tiles = [];
      items = [];
      extraPlayers = [];
      player = null;
      playerLimbs = {};

      const tileSize    = 0.9;
      const dirtHeight  = 0.6;
      const grassHeight = 0.2;

      for (let z = 0; z < GRID_SIZE; z++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = level.map[z][x];
          const hasItem = level.itemMapping && level.itemMapping[cell];
          const worldX = x - GRID_OFFSET;
          const worldZ = z - GRID_OFFSET;

          const dirtGeo  = new THREE.BoxGeometry(tileSize, dirtHeight, tileSize);
          const grassGeo = new THREE.BoxGeometry(tileSize * 0.98, grassHeight, tileSize * 0.98);

          const dirtMat  = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
          const grassCol = hasItem ? 0x3d7a3d : 0x55aa55;
          const grassMat = new THREE.MeshStandardMaterial({ color: grassCol });

          const dirt = new THREE.Mesh(dirtGeo, dirtMat);
          dirt.position.set(worldX, -grassHeight - dirtHeight / 2, worldZ);
          dirt.receiveShadow = true;
          levelGroup.add(dirt);

          const grass = new THREE.Mesh(grassGeo, grassMat);
          grass.position.set(worldX, -grassHeight / 2, worldZ);
          grass.receiveShadow = true;
          grass.castShadow = false;
          levelGroup.add(grass);
          tiles.push(grass);

          if (hasItem) {
            const shadowGeo = new THREE.PlaneGeometry(1.05, 1.05);
            const shadowMat = new THREE.MeshStandardMaterial({
              color: 0x000000,
              transparent: true,
              opacity: 0.35,
              side: THREE.DoubleSide
            });
            const shadow = new THREE.Mesh(shadowGeo, shadowMat);
            shadow.rotation.x = -Math.PI / 2;
            shadow.position.set(worldX, 0.01, worldZ);
            shadow.receiveShadow = true;
            levelGroup.add(shadow);

            const char = level.itemMapping[cell];
            const mesh = createZhuyinCard(char);
            const baseY = 1.2;
            mesh.position.set(worldX, baseY, worldZ);
            mesh.rotation.x = -Math.PI / 3.5;
            levelGroup.add(mesh);

            items.push({
              mesh,
              symbol: char,
              gridX: x,
              gridZ: z,
              collected: false,
              baseY: baseY,
              floatPhase: Math.random() * Math.PI * 2
            });
          }
        }
      }

      const steve = createSteve();
      player = steve.group;
      playerLimbs = steve.limbs;
      levelGroup.add(player);

      // 額外 1-2 個隨機 NPC（苦力怕 / 乳牛 / 小羊）
      const bannedForExtra = new Set();
      bannedForExtra.add(level.start.x + "," + level.start.z);
      for (const item of items) {
        bannedForExtra.add(item.gridX + "," + item.gridZ);
      }
      const extraCount = 1 + Math.floor(Math.random() * 2); // 1 或 2 個
      const extraPositions = getRandomGridPositions(extraCount, bannedForExtra);
      extraPositions.forEach(pos => {
        const type = Math.floor(Math.random() * 3); // 0: creeper, 1: cow, 2: sheep
        let g;
        if (type === 0) {
          g = createCreeper();
        } else if (type === 1) {
          g = createCow();
        } else {
          g = createSheep();
        }
        const worldX = pos.x - GRID_OFFSET;
        const worldZ = pos.z - GRID_OFFSET;
        g.position.set(worldX, 0, worldZ);
        g.rotation.y = DIR_ROTATIONS[Math.floor(Math.random() * DIR_ROTATIONS.length)];
        levelGroup.add(g);
        extraPlayers.push(g);
      });

      resetPlayer();
      updateLevelInfo();
    }

    function resizeRenderer() {
      if (!renderer || !camera) return;
      const canvas = renderer.domElement;
      const width = canvas.clientWidth || canvas.offsetWidth;
      const height = canvas.clientHeight || canvas.offsetHeight;
      if (!width || !height) return;
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    // 注音卡：只上下漂浮，不旋轉
    function animate(time) {
      requestAnimationFrame(animate);
      if (!renderer || !scene || !camera) return;

      const t = (time || 0) * 0.001;
      const floatAmp = 0.1;
      const floatSpeed = 1.5;

      for (const item of items) {
        if (!item.mesh || item.collected) continue;
        item.mesh.position.y =
          item.baseY + Math.sin(t * floatSpeed + item.floatPhase) * floatAmp;
      }

      renderer.render(scene, camera);
    }

    // ========= 執行 Blockly 程式 =========
    async function executeCommands(commands) {
      updateStatus("執行中，共 " + commands.length + " 個指令…");
      for (let i = 0; i < commands.length; i++) {
        const cmd = commands[i];
        if (cmd === "MOVE") {
          await animateMove();
        } else if (cmd === "LEFT") {
          await animateTurn(-1);
        } else if (cmd === "RIGHT") {
          await animateTurn(1);
        }
      }
      updateStatus("執行完畢，共 " + commands.length + " 個指令。");
    }

    async function runCode() {
      if (!workspace) return;
      let code = "";
      const commands = [];
      try {
        code = Blockly.JavaScript.workspaceToCode(workspace);
        const wrapped = new Function("commands", code);
        wrapped(commands);
      } catch (e) {
        console.error(e);
        alert("程式碼產生或執行錯誤：\n" + e);
        updateStatus("程式錯誤，請檢查積木。");
        return;
      }

      if (!commands.length) {
        updateStatus("目前沒有指令喔，先拖一些積木再按執行。");
        return;
      }

      await executeCommands(commands);
    }

    // ========= 初始化 =========
    window.addEventListener('load', function () {
      initBlockly();
      initThree();
      updateLevelInfo();

      document.getElementById('runBtn').addEventListener('click', function () {
        runCode();
      });
      document.getElementById('resetBtn').addEventListener('click', function () {
        resetPlayer();
        updateStatus("人物已重設到中央。");
      });

      const prevBtn = document.getElementById('prevLevelBtn');
      const nextBtn = document.getElementById('nextLevelBtn');
      if (prevBtn) {
        prevBtn.addEventListener('click', function () {
          if (currentLevelIndex > 0) {
            setLevel(currentLevelIndex - 1);
          }
        });
      }
      if (nextBtn) {
        nextBtn.addEventListener('click', function () {
          if (currentLevelIndex < LEVELS.length - 1) {
            setLevel(currentLevelIndex + 1);
          }
        });
      }

      const restartBtn = document.getElementById('dialogRestartBtn');
      const dialogNextBtn = document.getElementById('dialogNextBtn');
      if (restartBtn) {
        restartBtn.addEventListener('click', function () {
          resetPlayer();
          hideCompleteDialog();
        });
      }
      if (dialogNextBtn) {
        dialogNextBtn.addEventListener('click', function () {
          if (currentLevelIndex < LEVELS.length - 1) {
            setLevel(currentLevelIndex + 1);
          } else {
            hideCompleteDialog();
          }
        });
      }

      const completeDialog = document.getElementById('completeDialog');
      if (completeDialog) {
        completeDialog.addEventListener('click', function (e) {
          if (e.target.id === 'completeDialog') {
            hideCompleteDialog();
          }
        });
      }

      // 編輯關卡按鈕：更新本關 / 新增關卡
      const cfgApplyBtn = document.getElementById('cfgApplyCurrent');
      const cfgAddBtn   = document.getElementById('cfgAddLevel');
      const wordInput   = document.getElementById('cfgWordInput');
      const zhuyinInput = document.getElementById('cfgZhuyinInput');

      if (cfgApplyBtn) {
        cfgApplyBtn.addEventListener('click', function () {
          const w = (wordInput.value || "").trim();
          const z = (zhuyinInput.value || "").trim();
          if (!w || !z) {
            alert("請輸入國字和注音（注音中間用空格分開）。");
            return;
          }
          levelInputConfig[currentLevelIndex] = { word: w, zhuyin: z };
          rebuildLevelsAndStay(currentLevelIndex);
        });
      }

      if (cfgAddBtn) {
        cfgAddBtn.addEventListener('click', function () {
          const w = (wordInput.value || "").trim();
          const z = (zhuyinInput.value || "").trim();
          if (!w || !z) {
            alert("請輸入國字和注音（注音中間用空格分開）。");
            return;
          }
          levelInputConfig.push({ word: w, zhuyin: z });
          rebuildLevelsAndStay(levelInputConfig.length - 1);
        });
      }
    });
  </script>
</body>
</html>
