<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <title>注音麥塊小遊戲（Blockly + Three.js）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- Tailwind（純排版） -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- Blockly -->
  <script src="https://unpkg.com/blockly@9.3.3/blockly_compressed.js"></script>
  <script src="https://unpkg.com/blockly@9.3.3/blocks_compressed.js"></script>
  <script src="https://unpkg.com/blockly@9.3.3/javascript_compressed.js"></script>
  <script src="https://unpkg.com/blockly@9.3.3/msg/zh-hant.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* 防止整個網頁捲動 */
      font-family: "Microsoft JhengHei", "Noto Sans TC", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      touch-action: none; /* 禁止預設觸控行為，優化手機拖曳體驗 */
    }

    #blocklyDiv {
      width: 100%;
      height: 100%;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      outline: none;
    }

    /* Blockly 外觀微調 */
    .blocklyToolboxDiv {
      background-color: #f1f5f9 !important;
      border-bottom: 1px solid #cbd5f5 !important;
      box-sizing: border-box;
    }
    .blocklySvg {
      background-color: #ffffff !important;
    }
    .blocklyMainBackground {
      stroke: none !important;
    }
  </style>
</head>
<body class="bg-slate-900 text-white fixed inset-0">
  
  <!-- 主要容器：使用 h-screen 強制佔滿視窗 -->
  <!-- 手機：flex-col (垂直排列) -->
  <!-- 電腦 (md以上)：flex-row (水平排列) -->
  <div class="flex flex-col md:flex-row w-full h-screen overflow-hidden">
    
    <!-- 區域 1：遊戲畫面 (Three.js) -->
    <!-- 手機：高度佔 40vh (視窗高度的 40%)，順序 1 (最上面) -->
    <!-- 電腦：高度佔滿 (h-full)，寬度自動分配 (flex-1)，順序 2 (右邊) -->
    <div class="relative w-full h-[40vh] md:h-full md:flex-1 order-1 md:order-2 z-0 bg-sky-300">
      <canvas id="gameCanvas"></canvas>

      <!-- 資訊面板 -->
      <div id="info"
           class="absolute top-2 left-2 md:top-4 md:left-4 bg-black/70 text-sm md:text-lg px-3 py-2 md:px-5 md:py-4 rounded-lg pointer-events-auto z-10 shadow-lg max-w-[90%] md:max-w-md transition-all">
        <div class="space-y-1 md:space-y-2">
          <div id="wordInfo" class="font-bold text-yellow-300">國字：</div>
          <div id="zhuyinInfo" class="font-semibold">注音：</div>
          <div id="collectedInfo" class="text-slate-200 text-xs md:text-base">目前收集：尚未收集</div>
        </div>

        <div class="flex items-center gap-2 md:gap-3 pt-2 md:pt-3 mt-2 md:mt-3 border-t border-white/30">
          <button id="prevLevelBtn"
                  class="px-2 py-1 md:px-3 md:py-1.5 rounded bg-white/10 text-xs md:text-base hover:bg-white/20 disabled:opacity-40 disabled:hover:bg-white/10 transition">
            ◀
          </button>
          <div id="levelInfo" class="text-xs md:text-base font-medium whitespace-nowrap">
            1 / 1
          </div>
          <button id="nextLevelBtn"
                  class="px-2 py-1 md:px-3 md:py-1.5 rounded bg-white/10 text-xs md:text-base hover:bg-white/20 disabled:opacity-40 disabled:hover:bg-white/10 transition">
            ▶
          </button>
        </div>

        <!-- 編輯關卡面板 -->
        <details class="mt-2 md:mt-3 bg-black/40 rounded px-2 py-1 md:px-3 md:py-2 text-xs md:text-base">
          <summary class="cursor-pointer select-none font-medium text-slate-300 hover:text-white">
            編輯
          </summary>
          <div class="mt-2 space-y-2">
            <div class="flex items-center gap-2">
              <span class="shrink-0">國字</span>
              <input id="cfgWordInput"
                     class="w-16 md:w-28 px-1 md:px-2 py-0.5 md:py-1 rounded bg-white/90 text-slate-900 outline-none focus:ring-2 focus:ring-emerald-500" />
            </div>
            <div class="flex items-center gap-2">
              <span class="shrink-0">注音</span>
              <input id="cfgZhuyinInput"
                     placeholder="例：ㄕ ㄨ ㄣ ˋ"
                     class="w-24 md:w-40 px-1 md:px-2 py-0.5 md:py-1 rounded bg-white/90 text-slate-900 outline-none focus:ring-2 focus:ring-emerald-500" />
            </div>
            <div class="flex gap-2 pt-1">
              <button id="cfgApplyCurrent"
                      class="flex-1 px-2 py-1 rounded bg-emerald-500 text-white hover:bg-emerald-600 transition shadow">
                更新
              </button>
              <button id="cfgAddLevel"
                      class="flex-1 px-2 py-1 rounded bg-sky-500 text-white hover:bg-sky-600 transition shadow">
                新增
              </button>
            </div>
          </div>
        </details>
      </div>

      <!-- 狀態提示 -->
      <div id="status"
           class="absolute bottom-2 left-2 right-2 md:bottom-3 md:left-3 md:right-auto bg-black/60 text-xs md:text-sm px-3 py-2 rounded-md pointer-events-none z-10 text-center md:text-left">
        提示：組程式，按執行。
      </div>
    </div>

    <!-- 區域 2：Blockly 控制區 -->
    <!-- 手機：高度佔 60vh (剩下的 60%)，順序 2 (下面) -->
    <!-- 電腦：高度佔滿，寬度佔 1/3，順序 1 (左邊) -->
    <div class="relative w-full h-[60vh] md:h-full md:w-1/3 min-w-[300px] bg-slate-100 text-slate-900 flex flex-col border-t-2 md:border-t-0 md:border-r border-slate-400 order-2 md:order-1 z-10">
      <div class="px-4 py-2 border-b border-slate-300 bg-slate-50 flex items-center justify-between shrink-0">
        <div class="font-semibold text-slate-700">程式積木</div>
        <div class="text-xs text-slate-500">拖曳積木控制</div>
      </div>
      <div class="flex-1 relative w-full h-full overflow-hidden">
        <div id="blocklyDiv" class="absolute inset-0"></div>
      </div>
      <div class="px-4 py-3 border-t border-slate-300 bg-slate-50 flex gap-2 shrink-0">
        <button id="runBtn"
                class="flex-1 px-4 py-3 md:py-2 rounded-md bg-emerald-600 text-white text-base md:text-sm font-semibold hover:bg-emerald-700 active:scale-95 transition shadow-sm">
          ▶ 執行程式
        </button>
        <button id="resetBtn"
                class="px-4 py-3 md:py-2 rounded-md bg-slate-600 text-white text-base md:text-sm hover:bg-slate-700 active:scale-95 transition shadow-sm">
          ⟳
        </button>
      </div>
    </div>

  </div>

  <!-- 收集完成對話框 -->
  <div id="completeDialog"
       class="hidden fixed inset-0 flex items-center justify-center bg-black/60 z-50 px-4">
    <div class="bg-white text-slate-900 rounded-xl shadow-xl px-6 py-5 w-80 max-w-full text-center">
      <div id="dialogTitle" class="text-xl font-bold mb-3 text-emerald-600">太棒了！</div>
      <div id="dialogMessage" class="text-base mb-6 text-slate-600">
        你完成了關卡。
      </div>
      <div class="flex justify-center gap-3">
        <button id="dialogRestartBtn"
                class="flex-1 px-4 py-2 rounded-lg bg-slate-200 text-slate-700 font-semibold hover:bg-slate-300">
          重玩
        </button>
        <button id="dialogNextBtn"
                class="flex-1 px-4 py-2 rounded-lg bg-emerald-500 text-white font-semibold hover:bg-emerald-600 shadow-md">
          下一關
        </button>
      </div>
    </div>
  </div>

  <!-- 一般訊息對話框 (替代 alert) -->
  <div id="msgDialog" class="hidden fixed inset-0 flex items-center justify-center bg-black/60 z-50 px-4">
    <div class="bg-white text-slate-900 rounded-xl shadow-xl px-6 py-5 w-80 max-w-full text-center">
      <div class="text-lg font-semibold mb-2">提示</div>
      <div id="msgDialogText" class="text-sm mb-5 text-slate-600"></div>
      <button onclick="document.getElementById('msgDialog').classList.add('hidden')" class="w-full px-4 py-2 rounded-lg bg-slate-600 text-white text-sm hover:bg-slate-700">
        確定
      </button>
    </div>
  </div>

  <script>
    // ========= 替代 alert 的函式 =========
    function showMsg(text) {
      const el = document.getElementById('msgDialog');
      const txt = document.getElementById('msgDialogText');
      if (el && txt) {
        txt.textContent = text;
        el.classList.remove('hidden');
      } else {
        console.log(text);
      }
    }

    // ========= 教師預設關卡（載入時用這些當起點） =========
    let levelInputConfig = [
      { word: "順", zhuyin: "ㄕ ㄨ ㄣ ˋ" },
      { word: "媽", zhuyin: "ㄇ ㄚ ˊ" },
      { word: "家", zhuyin: "ㄐ ㄧ ㄚ" }
    ];

    // ========= 基本常數與隨機工具 =========
    const GRID_SIZE = 9;
    const GRID_OFFSET = Math.floor(GRID_SIZE / 2);

    const DIR_ROTATIONS = [
      Math.PI,        // 0: 面向 -z
      Math.PI / 2,    // 1: 面向 +x
      0,              // 2: 面向 +z（朝玩家）
      -Math.PI / 2    // 3: 面向 -x
    ];

    const MAX_ITEMS_PER_LEVEL = 4;

    // 從整個地圖挑隨機格子（排除 bannedSet 裡的 x,z）
    function getRandomGridPositions(count, bannedSet) {
      const positions = [];
      for (let z = 0; z < GRID_SIZE; z++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const key = x + "," + z;
          if (bannedSet && bannedSet.has(key)) continue;
          positions.push({ x, z });
        }
      }
      if (positions.length <= count) return positions;

      for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = positions[i];
        positions[i] = positions[j];
        positions[j] = tmp;
      }
      return positions.slice(0, count);
    }

    // ========= 建立 LEVELS 結構 =========
    function buildLevelsFromInput(configList) {
      const levels = [];

      configList.forEach((cfg, idx) => {
        if (!cfg) return;
        const word = cfg.word || ("第" + (idx + 1) + "關");
        const zhuyinArr = String(cfg.zhuyin || "")
          .split(/\s+/)
          .map(s => s.trim())
          .filter(Boolean);

        if (!zhuyinArr.length) return;

        const usedZhuyin = zhuyinArr.slice(0, MAX_ITEMS_PER_LEVEL);

        const map = Array.from({ length: GRID_SIZE }, () =>
          Array(GRID_SIZE).fill(1)
        );
        const itemMapping = {};

        const banned = new Set();
        // 不要放在起始點
        banned.add("4,4");

        const positions = getRandomGridPositions(usedZhuyin.length, banned);
        positions.forEach((pos, i) => {
          const sym = usedZhuyin[i];
          const code = 10 + i;
          map[pos.z][pos.x] = code;
          itemMapping[code] = sym;
        });

        levels.push({
          targetChar: word,
          targetZhuyin: usedZhuyin,
          map,
          itemMapping,
          start: { x: 4, z: 4, dir: 2 } // 一開始面向 +z（朝玩家）
        });
      });

      // 保底：若真的沒設定到，就塞一關預設
      if (!levels.length) {
        const map = Array.from({ length: GRID_SIZE }, () =>
          Array(GRID_SIZE).fill(1)
        );
        const itemMapping = {};
        const defaultZhuyin = ["ㄕ", "ㄨ", "ㄣ", "ˋ"];

        const banned = new Set();
        banned.add("4,4");
        const positions = getRandomGridPositions(defaultZhuyin.length, banned);

        positions.forEach((pos, i) => {
          const sym = defaultZhuyin[i];
          const code = 10 + i;
          map[pos.z][pos.x] = code;
          itemMapping[code] = sym;
        });

        levels.push({
          targetChar: "順",
          targetZhuyin: defaultZhuyin,
          map,
          itemMapping,
          start: { x: 4, z: 4, dir: 2 }
        });
      }

      return levels;
    }

    let LEVELS = buildLevelsFromInput(levelInputConfig);
    let currentLevelIndex = 0;

    // ========= 全域變數 =========
    let workspace = null;

    let scene = null;
    let camera = null;
    let renderer = null;
    let levelGroup = null;

    let player = null;
    let playerLimbs = {};

    let tiles = [];
    let items = [];
    let extraPlayers = [];
    let collectedSymbols = [];

    const playerState = { x: 0, z: 0, dir: 0 };

    // ========= UI 小工具 =========
    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    function updateStatus(text) {
      const el = document.getElementById('status');
      if (el) el.textContent = text;
    }

    function updateCollectedInfo() {
      const el = document.getElementById('collectedInfo');
      if (!el) return;
      if (collectedSymbols.length === 0) {
        el.textContent = "目前收集：尚未收集";
      } else {
        el.textContent = "目前收集：" + collectedSymbols.join(" ");
      }
    }

    function updateLevelNavButtons() {
      const prevBtn = document.getElementById('prevLevelBtn');
      const nextBtn = document.getElementById('nextLevelBtn');
      if (prevBtn) prevBtn.disabled = (currentLevelIndex === 0);
      if (nextBtn) nextBtn.disabled = (currentLevelIndex === LEVELS.length - 1);
    }

    function fillLevelFormFromConfig() {
      const wordInput = document.getElementById('cfgWordInput');
      const zhuyinInput = document.getElementById('cfgZhuyinInput');
      if (!wordInput || !zhuyinInput) return;
      const cfg = levelInputConfig[currentLevelIndex];
      if (!cfg) {
        wordInput.value = "";
        zhuyinInput.value = "";
      } else {
        wordInput.value = cfg.word || "";
        zhuyinInput.value = cfg.zhuyin || "";
      }
    }

    function updateLevelInfo() {
      const level = LEVELS[currentLevelIndex];
      const wEl = document.getElementById('wordInfo');
      const zEl = document.getElementById('zhuyinInfo');
      const lEl = document.getElementById('levelInfo');

      if (level) {
        if (wEl) wEl.textContent = "國字：" + (level.targetChar || "");
        if (zEl) zEl.textContent = "注音：" + level.targetZhuyin.join(" ");
      }
      if (lEl) {
        lEl.textContent =
          (currentLevelIndex + 1) + " / " + LEVELS.length;
      }
      updateCollectedInfo();
      updateLevelNavButtons();
      fillLevelFormFromConfig();
    }

    function showCompleteDialog(level) {
      const dialog = document.getElementById('completeDialog');
      const msgEl  = document.getElementById('dialogMessage');
      const nextBtn = document.getElementById('dialogNextBtn');

      if (level && msgEl) {
        msgEl.textContent =
          "你用 " + level.targetZhuyin.join(" ") +
          " 組成了「" + level.targetChar + "」！";
      }

      if (nextBtn) {
        if (currentLevelIndex === LEVELS.length - 1) {
          nextBtn.textContent = "關閉";
        } else {
          nextBtn.textContent = "下一關";
        }
      }

      if (dialog) dialog.classList.remove('hidden');
    }

    function hideCompleteDialog() {
      const dialog = document.getElementById('completeDialog');
      if (dialog) dialog.classList.add('hidden');
    }

    function setLevel(index) {
      if (index < 0 || index >= LEVELS.length) return;
      currentLevelIndex = index;
      buildLevel(currentLevelIndex);
      hideCompleteDialog();
      updateLevelInfo();
      updateStatus("已切換到第 " + (currentLevelIndex + 1) + " 關。");
    }

    function rebuildLevelsAndStay(targetIndex) {
      const oldIndex = (typeof targetIndex === "number") ? targetIndex : currentLevelIndex;
      LEVELS = buildLevelsFromInput(levelInputConfig);
      let newIndex = oldIndex;
      if (newIndex < 0) newIndex = 0;
      if (newIndex >= LEVELS.length) newIndex = LEVELS.length - 1;
      currentLevelIndex = newIndex;
      buildLevel(currentLevelIndex);
      hideCompleteDialog();
      updateLevelInfo();
      updateStatus("關卡設定已更新。");
    }

    // ========= Blockly 設定 =========
    function defineBlocks() {
      Blockly.Blocks['mc_move'] = {
        init: function () {
          this.appendDummyInput().appendField("前進一格");
          this.setPreviousStatement(true, null);
          this.setNextStatement(true, null);
          this.setColour(200);
        }
      };
      Blockly.JavaScript['mc_move'] = function (block) {
        return 'commands.push("MOVE");\n';
      };

      Blockly.Blocks['mc_turn_left'] = {
        init: function () {
          this.appendDummyInput().appendField("向左轉");
          this.setPreviousStatement(true, null);
          this.setNextStatement(true, null);
          this.setColour(180);
        }
      };
      Blockly.JavaScript['mc_turn_left'] = function (block) {
        return 'commands.push("LEFT");\n';
      };

      Blockly.Blocks['mc_turn_right'] = {
        init: function () {
          this.appendDummyInput().appendField("向右轉");
          this.setPreviousStatement(true, null);
          this.setNextStatement(true, null);
          this.setColour(180);
        }
      };
      Blockly.JavaScript['mc_turn_right'] = function (block) {
        return 'commands.push("RIGHT");\n';
      };
    }

    function initBlockly() {
      defineBlocks();

      const toolbox = `
        <xml xmlns="https://developers.google.com/blockly/xml">
          <block type="mc_move"></block>
          <block type="mc_turn_left"></block>
          <block type="mc_turn_right"></block>
          <block type="controls_repeat_ext">
            <value name="TIMES">
              <shadow type="math_number">
                <field name="NUM">4</field>
              </shadow>
            </value>
          </block>
        </xml>
      `;

      workspace = Blockly.inject('blocklyDiv', {
        toolbox: toolbox,
        scrollbars: true,
        trashcan: true,
        horizontalLayout: true,
        toolboxPosition: 'top',
        zoom: {
          startScale: 1.0,
          maxScale: 2.5,
          minScale: 0.5,
          scaleSpeed: 1.2
        }
      });

      window.addEventListener('resize', function () {
        if (workspace) {
          Blockly.svgResize(workspace);
        }
      });
    }

    // ========= 基本方塊產生器 =========
    function createVoxel(color, x, y, z, sx, sy, sz) {
      const geometry = new THREE.BoxGeometry(sx, sy, sz);
      const material = new THREE.MeshStandardMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    // ========= 材質產生器（像素雜訊） =========
    function createNoiseTexture(colorHex) {
      const size = 64; // 貼圖大小
      const data = new Uint8Array(size * size * 4);
      const baseColor = new THREE.Color(colorHex);
      
      for (let i = 0; i < size * size; i++) {
        // 雜訊範圍：在基礎顏色上做微小偏移
        // (Math.random() - 0.5) * 0.15 代表 RGB 變動約 +/- 7%
        const n = (Math.random() - 0.5) * 0.15;
        
        const r = Math.min(1, Math.max(0, baseColor.r + n));
        const g = Math.min(1, Math.max(0, baseColor.g + n));
        const b = Math.min(1, Math.max(0, baseColor.b + n));
        
        data[i * 4] = Math.floor(r * 255);
        data[i * 4 + 1] = Math.floor(g * 255);
        data[i * 4 + 2] = Math.floor(b * 255);
        data[i * 4 + 3] = 255; // Alpha
      }
      
      const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
      texture.needsUpdate = true;
      // 設定 NearestFilter 讓放大的時候有像素顆粒感，不要模糊
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      return texture;
    }

    // ========= 主角：Steve =========
    function createSteve() {
      const steveGroup = new THREE.Group();
      const skin = 0xCF9E7A;
      const hair = 0x3A2208;

      // 頭
      const head = new THREE.Group();
      head.position.y = 1.5;
      head.add(createVoxel(skin, 0, 0, 0, 0.4, 0.4, 0.4));
      head.add(createVoxel(hair, 0, 0.21, 0, 0.42, 0.05, 0.42));
      head.add(createVoxel(hair, 0, 0.1, -0.21, 0.42, 0.2, 0.05));
      head.add(createVoxel(hair, -0.21, 0.1, 0, 0.05, 0.2, 0.4));
      head.add(createVoxel(hair, 0.21, 0.1, 0, 0.05, 0.2, 0.4));

      const fz = 0.205;
      head.add(createVoxel(0xFFFFFF,  0.1,  0.05, fz,         0.1, 0.05, 0.02));
      head.add(createVoxel(0x2222FF,  0.12, 0.05, fz + 0.001, 0.05, 0.05, 0.02));
      head.add(createVoxel(0xFFFFFF, -0.1,  0.05, fz,         0.1, 0.05, 0.02));
      head.add(createVoxel(0x2222FF, -0.12, 0.05, fz + 0.001, 0.05, 0.05, 0.02));
      head.add(createVoxel(0xB87E6A, 0, -0.05, fz, 0.08, 0.05, 0.02));
      head.add(createVoxel(0x9E6A4A, 0, -0.12, fz, 0.2,  0.06, 0.02));

      steveGroup.add(head);

      // 身體
      steveGroup.add(createVoxel(0x009999, 0, 0.9, 0, 0.4, 0.6, 0.2));

      // 四肢
      const limbs = {};

      function mkLimb(x, y, color, w, h, d, isLeg) {
        const g = new THREE.Group();
        g.position.set(x, y, 0);
        g.add(createVoxel(color, 0, -h / 2 + (isLeg ? 0 : 0.1), 0, w, h, d));
        steveGroup.add(g);
        return g;
      }

      limbs.armL = mkLimb(-0.3, 1.1, skin,     0.18, 0.6, 0.18, false);
      limbs.armR = mkLimb( 0.3, 1.1, skin,     0.18, 0.6, 0.18, false);
      limbs.legL = mkLimb(-0.1, 0.6, 0x0000AA, 0.18, 0.6, 0.18, true);
      limbs.legR = mkLimb( 0.1, 0.6, 0x0000AA, 0.18, 0.6, 0.18, true);

      return { group: steveGroup, limbs: limbs };
    }

    // ========= NPC：多樣化生物 =========
    
    // 1. 苦力怕 (Creeper)
    function createCreeper() {
      const group = new THREE.Group();
      const green = 0x3ba635;
      const dark = 0x000000;

      // 身體
      group.add(createVoxel(green, 0, 0.9, 0, 0.5, 1.0, 0.4));
      // 頭
      const head = new THREE.Group();
      head.position.y = 1.6;
      head.add(createVoxel(green, 0, 0, 0, 0.5, 0.5, 0.5));
      // 臉部特徵 (簡單示意)
      head.add(createVoxel(dark, -0.1, 0.05, 0.26, 0.1, 0.1, 0.02)); // 左眼
      head.add(createVoxel(dark, 0.1, 0.05, 0.26, 0.1, 0.1, 0.02));  // 右眼
      head.add(createVoxel(dark, 0, -0.1, 0.26, 0.12, 0.12, 0.02)); // 嘴
      group.add(head);

      // 腿
      const legHeight = 0.3;
      const legY = 0.15;
      const legs = [
        [-0.15, legY, -0.12],
        [ 0.15, legY, -0.12],
        [-0.15, legY,  0.12],
        [ 0.15, legY,  0.12]
      ];
      legs.forEach(([x, y, z]) => {
        group.add(createVoxel(green, x, y, z, 0.18, legHeight, 0.18));
      });
      return group;
    }

    // 2. 乳牛 (Cow)
    function createCow() {
      const group = new THREE.Group();
      const bodyColor = 0x8b4513;
      const spotColor = 0xffffff;
      const legColor = 0x4b3621;

      // 身體
      group.add(createVoxel(bodyColor, 0, 0.7, 0, 0.9, 0.5, 0.5));
      // 斑點
      group.add(createVoxel(spotColor, 0.15, 0.8, 0.26, 0.2, 0.2, 0.05));
      group.add(createVoxel(spotColor, -0.25, 0.6, -0.26, 0.25, 0.15, 0.05));
      // 頭
      const head = new THREE.Group();
      head.position.set(0, 1.0, 0.4);
      head.add(createVoxel(bodyColor, 0, 0, 0, 0.4, 0.4, 0.4));
      // 角
      head.add(createVoxel(0x222222, -0.22, 0.2, 0, 0.05, 0.12, 0.05));
      head.add(createVoxel(0x222222, 0.22, 0.2, 0, 0.05, 0.12, 0.05));
      group.add(head);

      // 腿
      const legH = 0.4;
      const legY = 0.2;
      const legs = [
        [-0.3, legY, -0.18],
        [ 0.3, legY, -0.18],
        [-0.3, legY,  0.18],
        [ 0.3, legY,  0.18]
      ];
      legs.forEach(([x, y, z]) => {
        group.add(createVoxel(legColor, x, y, z, 0.18, legH, 0.18));
      });
      return group;
    }

    // 3. 羊 (Sheep)
    function createSheep() {
      const group = new THREE.Group();
      const wool = 0xffffff;
      const face = 0xd8c0a8;
      const legColor = 0xd8c0a8;

      // 身體 (毛)
      group.add(createVoxel(wool, 0, 0.8, 0, 0.9, 0.6, 0.5));
      // 頭
      group.add(createVoxel(face, 0, 0.85, 0.45, 0.4, 0.4, 0.4));
      // 腿
      const legH = 0.35;
      const legY = 0.175;
      const legs = [
        [-0.3, legY, -0.18],
        [ 0.3, legY, -0.18],
        [-0.3, legY,  0.18],
        [ 0.3, legY,  0.18]
      ];
      legs.forEach(([x, y, z]) => {
        group.add(createVoxel(legColor, x, y, z, 0.18, legH, 0.18));
      });
      return group;
    }

    // 4. 終界使者 (Enderman) - 高挑、黑紫色
    function createEnderman() {
      const group = new THREE.Group();
      const black = 0x111111;
      const purple = 0xcc00cc;

      // 身體 (短)
      group.add(createVoxel(black, 0, 1.4, 0, 0.4, 0.6, 0.2));
      
      // 頭
      const head = new THREE.Group();
      head.position.y = 1.95;
      head.add(createVoxel(black, 0, 0, 0, 0.4, 0.4, 0.4));
      // 眼睛
      head.add(createVoxel(purple, -0.12, -0.05, 0.21, 0.1, 0.05, 0.02));
      head.add(createVoxel(purple, 0.12, -0.05, 0.21, 0.1, 0.05, 0.02));
      group.add(head);

      // 手臂 (長)
      group.add(createVoxel(black, -0.28, 1.3, 0, 0.08, 0.9, 0.08));
      group.add(createVoxel(black, 0.28, 1.3, 0, 0.08, 0.9, 0.08));

      // 腿 (長)
      group.add(createVoxel(black, -0.1, 0.55, 0, 0.1, 1.1, 0.1));
      group.add(createVoxel(black, 0.1, 0.55, 0, 0.1, 1.1, 0.1));

      return group;
    }

    // 5. 蜘蛛 (Spider) - 扁平、多腳
    function createSpider() {
      const group = new THREE.Group();
      const darkGrey = 0x222222;
      const red = 0xff0000;

      // 頭
      const head = new THREE.Group();
      head.position.set(0, 0.4, 0.4);
      head.add(createVoxel(darkGrey, 0, 0, 0, 0.35, 0.3, 0.35));
      // 眼睛
      head.add(createVoxel(red, -0.1, 0.05, 0.18, 0.08, 0.05, 0.02));
      head.add(createVoxel(red, 0.1, 0.05, 0.18, 0.08, 0.05, 0.02));
      group.add(head);

      // 身體 (後)
      group.add(createVoxel(darkGrey, 0, 0.45, -0.2, 0.5, 0.35, 0.6));

      // 腳 (簡化為6隻)
      const legY = 0.3;
      const legParams = [
        [-0.4, legY, 0.2], [0.4, legY, 0.2],
        [-0.45, legY, 0], [0.45, legY, 0],
        [-0.4, legY, -0.3], [0.4, legY, -0.3]
      ];
      legParams.forEach(([x, y, z]) => {
        group.add(createVoxel(darkGrey, x, y, z, 0.3, 0.08, 0.08));
      });

      return group;
    }

    // 6. 狼 (Wolf) - 灰白色、有尾巴
    function createWolf() {
      const group = new THREE.Group();
      const fur = 0xdddddd;
      const nose = 0x333333;

      // 身體
      group.add(createVoxel(fur, 0, 0.5, 0, 0.4, 0.4, 0.7));
      
      // 頭
      const head = new THREE.Group();
      head.position.set(0, 0.8, 0.35);
      head.add(createVoxel(fur, 0, 0, 0, 0.35, 0.35, 0.35));
      // 鼻子
      head.add(createVoxel(nose, 0, -0.05, 0.2, 0.15, 0.15, 0.1));
      // 耳朵
      head.add(createVoxel(fur, -0.1, 0.2, 0.05, 0.08, 0.1, 0.05));
      head.add(createVoxel(fur, 0.1, 0.2, 0.05, 0.08, 0.1, 0.05));
      group.add(head);

      // 腿
      const legH = 0.3;
      const legY = 0.15;
      const legs = [
        [-0.12, legY, -0.25], [0.12, legY, -0.25],
        [-0.12, legY, 0.25], [0.12, legY, 0.25]
      ];
      legs.forEach(([x, y, z]) => {
        group.add(createVoxel(fur, x, y, z, 0.12, legH, 0.12));
      });

      // 尾巴
      group.add(createVoxel(fur, 0, 0.5, -0.4, 0.1, 0.1, 0.3));

      return group;
    }

    // 7. 雪人 (Snow Golem) - 雪球身體、南瓜頭
    function createSnowGolem() {
      const group = new THREE.Group();
      const snow = 0xffffff;
      const pumpkin = 0xd35400;

      // 下身 (大雪球)
      group.add(createVoxel(snow, 0, 0.4, 0, 0.6, 0.6, 0.6));
      // 上身 (中雪球)
      group.add(createVoxel(snow, 0, 0.9, 0, 0.45, 0.45, 0.45));
      
      // 頭 (南瓜)
      const head = new THREE.Group();
      head.position.y = 1.35;
      head.add(createVoxel(pumpkin, 0, 0, 0, 0.4, 0.45, 0.4));
      group.add(head);

      // 手 (樹枝)
      group.add(createVoxel(0x5d4037, -0.35, 1.0, 0, 0.3, 0.05, 0.05));
      group.add(createVoxel(0x5d4037, 0.35, 1.0, 0, 0.3, 0.05, 0.05));

      return group;
    }

    // ========= 背景雲朵 =========
    function initClouds() {
      const cloudsGroup = new THREE.Group();
      
      // 修正：改用 MeshBasicMaterial 確保是「純白色」，不受光影變黃影響
      const cloudMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.8
      });
      
      // 產生 15 朵雲
      for (let i = 0; i < 15; i++) {
        const cloud = new THREE.Group();
        const chunks = 3 + Math.floor(Math.random() * 4);
        
        for (let j = 0; j < chunks; j++) {
          const sx = 1.5 + Math.random() * 1.5;
          const sy = 0.5 + Math.random() * 0.5;
          const sz = 1.0 + Math.random() * 1.0;
          
          const ox = (Math.random() - 0.5) * 2.5;
          const oy = (Math.random() - 0.5) * 0.5;
          const oz = (Math.random() - 0.5) * 1.5;
          
          // 使用雲朵專用材質創建 mesh
          const geo = new THREE.BoxGeometry(sx, sy, sz);
          const mesh = new THREE.Mesh(geo, cloudMat);
          mesh.position.set(ox, oy, oz);
          mesh.castShadow = false; 
          cloud.add(mesh);
        }
        
        // 修正位置：確保雲朵在背景深處且高度適當
        const x = (Math.random() - 0.5) * 60; 
        const z = -20 - Math.random() * 30; // 深度
        const y = 2 + Math.random() * 1.5;    // 高度，微調一下讓它不會被地面遮住
        
        cloud.position.set(x, y, z);
        cloudsGroup.add(cloud);
      }
      scene.add(cloudsGroup);
    }

    // ========= 主角動作 =========
    function setIdlePose() {
      if (!playerLimbs.armL) return;
      playerLimbs.armL.rotation.x = 0;
      playerLimbs.armR.rotation.x = 0;
      playerLimbs.legL.rotation.x = 0;
      playerLimbs.legR.rotation.x = 0;
    }

    function updateWalkAnimation(progress) {
      if (!playerLimbs.armL) return;
      const swing = Math.sin(progress * Math.PI) * 0.7;
      playerLimbs.armL.rotation.x =  swing;
      playerLimbs.armR.rotation.x = -swing;
      playerLimbs.legL.rotation.x = -swing;
      playerLimbs.legR.rotation.x =  swing;
    }

    function updatePlayerTransform() {
      if (!player) return;
      const worldX = playerState.x - GRID_OFFSET;
      const worldZ = playerState.z - GRID_OFFSET;
      player.position.set(worldX, 0, worldZ);
      player.rotation.y = DIR_ROTATIONS[playerState.dir];
    }

    function resetPlayer() {
      const level = LEVELS[currentLevelIndex];
      playerState.x = level.start.x;
      playerState.z = level.start.z;
      playerState.dir = level.start.dir;

      collectedSymbols = [];
      items.forEach(item => {
        item.collected = false;
        item.mesh.visible = true;
      });

      updatePlayerTransform();
      setIdlePose();
      hideCompleteDialog();
      updateCollectedInfo();
    }

    // ========= 注音字卡（平面避免硬邊）與收集判定 =========
    function createZhuyinCard(char) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, 256, 256);

      ctx.font = 'bold 210px "Microsoft JhengHei", "Noto Sans TC", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // 外圈淡藍光暈，柔化邊緣
      ctx.lineWidth = 18;
      ctx.strokeStyle = 'rgba(0,255,255,0.7)';
      ctx.strokeText(char, 128, 140);

      // 主字
      ctx.lineWidth = 10;
      ctx.strokeStyle = '#FFFFFF';
      ctx.strokeText(char, 128, 140);
      ctx.fillStyle = '#00FFFF';
      ctx.fillText(char, 128, 140);

      const texture = new THREE.CanvasTexture(canvas);
      if (renderer) {
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      }
      texture.needsUpdate = true;

      // 改用「平面」，就不會有厚度邊線
      const geometry = new THREE.PlaneGeometry(1.3, 1.3);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });

      const mesh = new THREE.Mesh(geometry, material);
      return mesh;
    }

    function checkPickup() {
      const level = LEVELS[currentLevelIndex];
      if (!level) return;

      for (const item of items) {
        if (!item.collected &&
            item.gridX === playerState.x &&
            item.gridZ === playerState.z) {

          if (collectedSymbols.length >= level.targetZhuyin.length) {
            updateStatus("你已經收集完所有注音了，可以重設或切換關卡。");
            return;
          }

          const expected = level.targetZhuyin[collectedSymbols.length];
          if (item.symbol === expected) {
            item.collected = true;
            item.mesh.visible = false;
            collectedSymbols.push(item.symbol);
            updateCollectedInfo();
            updateStatus("收集到：「" + item.symbol + "」，目前：" + collectedSymbols.join(" "));

            if (collectedSymbols.length === level.targetZhuyin.length) {
              updateStatus("太棒了！你用 " +
                level.targetZhuyin.join(" ") +
                " 組成了「" + level.targetChar + "」。");
              showCompleteDialog(level);
            }
          } else {
            updateStatus("順序錯誤！應先收集「" +
              expected + "」，但你踩到「" + item.symbol + "」。");
          }
          break;
        }
      }
    }

    // ========= 移動與轉向動畫 =========
    async function animateMove() {
      const dirVecs = [
        { dx: 0, dz: -1 },
        { dx: 1, dz:  0 },
        { dx: 0, dz:  1 },
        { dx: -1,dz:  0 }
      ];
      const v = dirVecs[playerState.dir];
      const nx = playerState.x + v.dx;
      const nz = playerState.z + v.dz;

      if (nx < 0 || nx >= GRID_SIZE || nz < 0 || nz >= GRID_SIZE) {
        updateStatus("撞到邊界了，不能再前進！");
        return;
      }

      const startX = player.position.x;
      const startZ = player.position.z;
      const endX   = startX + v.dx;
      const endZ   = startZ + v.dz;

      const duration = 280;
      const steps = 14;

      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        player.position.x = startX + (endX - startX) * t;
        player.position.z = startZ + (endZ - startZ) * t;
        updateWalkAnimation(t);
        await delay(duration / steps);
      }

      playerState.x = nx;
      playerState.z = nz;
      updatePlayerTransform();
      setIdlePose();
      checkPickup();
    }

    async function animateTurn(deltaDir) {
      const oldDir = playerState.dir;
      const newDir = (playerState.dir + deltaDir + 4) % 4;
      const startRot = DIR_ROTATIONS[oldDir];
      const endRot   = DIR_ROTATIONS[newDir];

      const duration = 200;
      const steps = 12;

      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const angle = startRot + (endRot - startRot) * t;
        player.rotation.y = angle;
        await delay(duration / steps);
      }

      playerState.dir = newDir;
      updatePlayerTransform();
      setIdlePose();
    }

    // ========= Three.js 場景與關卡建立 =========
    function initThree() {
      const canvas = document.getElementById('gameCanvas');
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.shadowMap.enabled = true;

      scene = new THREE.Scene();
      // 修改背景顏色為漸層天空藍
      scene.background = new THREE.Color(0x87ceeb); // 原本的顏色

      const width = canvas.clientWidth || canvas.offsetWidth || 800;
      const height = canvas.clientHeight || canvas.offsetHeight || 600;
      camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
      camera.position.set(0, 6, 12);
      camera.lookAt(0, 0, 0);
      renderer.setSize(width, height, false);

      // 調整環境光：天空光偏暖，地面光偏冷
      const hemiLight = new THREE.HemisphereLight(0xffeeb1, 0x080820, 0.8);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);

      // 調整直射光：模擬太陽光
      const dirLight = new THREE.DirectionalLight(0xffaa33, 0.8);
      dirLight.position.set(5, 10, 7);
      dirLight.castShadow = true;
      // 增加陰影的柔和度
      dirLight.shadow.mapSize.width = 1024;
      dirLight.shadow.mapSize.height = 1024;
      scene.add(dirLight);

      buildLevel(currentLevelIndex);
      initClouds(); // 新增雲朵
      animate();

      window.addEventListener('resize', function () {
        resizeRenderer();
      });
    }

    function buildLevel(levelIndex) {
      const level = LEVELS[levelIndex];
      if (!level || !scene) return;

      if (levelGroup) {
        scene.remove(levelGroup);
      }
      levelGroup = new THREE.Group();
      scene.add(levelGroup);

      tiles = [];
      items = [];
      extraPlayers = [];
      player = null;
      playerLimbs = {};

      const tileSize    = 0.9;
      const dirtHeight  = 0.6;
      const grassHeight = 0.2;

      // 預先建立草地貼圖，節省效能並保持統一風格
      // 顏色改為較深的綠色，讓畫面更沉穩
      const normalGrassTex = createNoiseTexture(0x337733); // 一般草地：深綠
      const darkGrassTex   = createNoiseTexture(0x225522); // 有道具草地：更深綠

      for (let z = 0; z < GRID_SIZE; z++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = level.map[z][x];
          const hasItem = level.itemMapping && level.itemMapping[cell];
          const worldX = x - GRID_OFFSET;
          const worldZ = z - GRID_OFFSET;

          const dirtGeo  = new THREE.BoxGeometry(tileSize, dirtHeight, tileSize);
          const grassGeo = new THREE.BoxGeometry(tileSize * 0.98, grassHeight, tileSize * 0.98);

          const dirtMat  = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
          
          // 修改處：使用產生出來的像素雜訊貼圖，而不是單純顏色
          const grassMat = new THREE.MeshStandardMaterial({ 
            map: hasItem ? darkGrassTex : normalGrassTex
          });

          const dirt = new THREE.Mesh(dirtGeo, dirtMat);
          dirt.position.set(worldX, -grassHeight - dirtHeight / 2, worldZ);
          dirt.receiveShadow = true;
          levelGroup.add(dirt);

          const grass = new THREE.Mesh(grassGeo, grassMat);
          grass.position.set(worldX, -grassHeight / 2, worldZ);
          grass.receiveShadow = true;
          grass.castShadow = false;
          levelGroup.add(grass);
          tiles.push(grass);

          if (hasItem) {
            const shadowGeo = new THREE.PlaneGeometry(1.05, 1.05);
            const shadowMat = new THREE.MeshStandardMaterial({
              color: 0x000000,
              transparent: true,
              opacity: 0.35,
              side: THREE.DoubleSide
            });
            const shadow = new THREE.Mesh(shadowGeo, shadowMat);
            shadow.rotation.x = -Math.PI / 2;
            shadow.position.set(worldX, 0.01, worldZ);
            shadow.receiveShadow = true;
            levelGroup.add(shadow);

            const char = level.itemMapping[cell];
            const mesh = createZhuyinCard(char);
            const baseY = 1.2;
            mesh.position.set(worldX, baseY, worldZ);
            mesh.rotation.x = -Math.PI / 3.5;
            levelGroup.add(mesh);

            items.push({
              mesh,
              symbol: char,
              gridX: x,
              gridZ: z,
              collected: false,
              baseY: baseY,
              floatPhase: Math.random() * Math.PI * 2
            });
          }
        }
      }

      const steve = createSteve();
      player = steve.group;
      playerLimbs = steve.limbs;
      levelGroup.add(player);

      // 額外 1-2 個隨機 NPC
      const bannedForExtra = new Set();
      bannedForExtra.add(level.start.x + "," + level.start.z);
      for (const item of items) {
        bannedForExtra.add(item.gridX + "," + item.gridZ);
      }
      const extraCount = 1 + Math.floor(Math.random() * 2); // 1 或 2 個
      const extraPositions = getRandomGridPositions(extraCount, bannedForExtra);
      
      // 定義所有可用的 NPC 建立函式
      const npcCreators = [
        createCreeper,     // 苦力怕
        createCow,         // 乳牛
        createSheep,       // 羊
        createEnderman,    // 終界使者 (新)
        createSpider,      // 蜘蛛 (新)
        createWolf,        // 狼 (新)
        createSnowGolem    // 雪人 (新)
      ];

      extraPositions.forEach(pos => {
        // 隨機選一個種類
        const typeIdx = Math.floor(Math.random() * npcCreators.length);
        const g = npcCreators[typeIdx]();

        const worldX = pos.x - GRID_OFFSET;
        const worldZ = pos.z - GRID_OFFSET;
        g.position.set(worldX, 0, worldZ);
        g.rotation.y = DIR_ROTATIONS[Math.floor(Math.random() * DIR_ROTATIONS.length)];
        levelGroup.add(g);
        extraPlayers.push(g);
      });

      resetPlayer();
      updateLevelInfo();
    }

    function resizeRenderer() {
      if (!renderer || !camera) return;
      const canvas = renderer.domElement;
      const width = canvas.clientWidth || canvas.offsetWidth;
      const height = canvas.clientHeight || canvas.offsetHeight;
      if (!width || !height) return;
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    // 注音卡：只上下漂浮，不旋轉
    function animate(time) {
      requestAnimationFrame(animate);
      if (!renderer || !scene || !camera) return;

      const t = (time || 0) * 0.001;
      const floatAmp = 0.1;
      const floatSpeed = 1.5;

      for (const item of items) {
        if (!item.mesh || item.collected) continue;
        item.mesh.position.y =
          item.baseY + Math.sin(t * floatSpeed + item.floatPhase) * floatAmp;
      }

      renderer.render(scene, camera);
    }

    // ========= 執行 Blockly 程式 =========
    async function executeCommands(commands) {
      updateStatus("執行中，共 " + commands.length + " 個指令…");
      for (let i = 0; i < commands.length; i++) {
        const cmd = commands[i];
        if (cmd === "MOVE") {
          await animateMove();
        } else if (cmd === "LEFT") {
          await animateTurn(-1);
        } else if (cmd === "RIGHT") {
          await animateTurn(1);
        }
      }
      updateStatus("執行完畢，共 " + commands.length + " 個指令。");
    }

    async function runCode() {
      if (!workspace) return;
      let code = "";
      const commands = [];
      try {
        code = Blockly.JavaScript.workspaceToCode(workspace);
        const wrapped = new Function("commands", code);
        wrapped(commands);
      } catch (e) {
        console.error(e);
        showMsg("程式碼產生或執行錯誤：\n" + e);
        updateStatus("程式錯誤，請檢查積木。");
        return;
      }

      if (!commands.length) {
        updateStatus("目前沒有指令喔，先拖一些積木再按執行。");
        return;
      }

      await executeCommands(commands);
    }

    // ========= 初始化 =========
    window.addEventListener('load', function () {
      initBlockly();
      initThree();
      updateLevelInfo();

      document.getElementById('runBtn').addEventListener('click', function () {
        runCode();
      });
      document.getElementById('resetBtn').addEventListener('click', function () {
        resetPlayer();
        updateStatus("人物已重設到中央。");
      });

      const prevBtn = document.getElementById('prevLevelBtn');
      const nextBtn = document.getElementById('nextLevelBtn');
      if (prevBtn) {
        prevBtn.addEventListener('click', function () {
          if (currentLevelIndex > 0) {
            setLevel(currentLevelIndex - 1);
          }
        });
      }
      if (nextBtn) {
        nextBtn.addEventListener('click', function () {
          if (currentLevelIndex < LEVELS.length - 1) {
            setLevel(currentLevelIndex + 1);
          }
        });
      }

      const restartBtn = document.getElementById('dialogRestartBtn');
      const dialogNextBtn = document.getElementById('dialogNextBtn');
      if (restartBtn) {
        restartBtn.addEventListener('click', function () {
          resetPlayer();
          hideCompleteDialog();
        });
      }
      if (dialogNextBtn) {
        dialogNextBtn.addEventListener('click', function () {
          if (currentLevelIndex < LEVELS.length - 1) {
            setLevel(currentLevelIndex + 1);
          } else {
            hideCompleteDialog();
          }
        });
      }

      const completeDialog = document.getElementById('completeDialog');
      if (completeDialog) {
        completeDialog.addEventListener('click', function (e) {
          if (e.target.id === 'completeDialog') {
            hideCompleteDialog();
          }
        });
      }

      // 編輯關卡按鈕：更新本關 / 新增關卡
      const cfgApplyBtn = document.getElementById('cfgApplyCurrent');
      const cfgAddBtn   = document.getElementById('cfgAddLevel');
      const wordInput   = document.getElementById('cfgWordInput');
      const zhuyinInput = document.getElementById('cfgZhuyinInput');

      if (cfgApplyBtn) {
        cfgApplyBtn.addEventListener('click', function () {
          const w = (wordInput.value || "").trim();
          const z = (zhuyinInput.value || "").trim();
          if (!w || !z) {
            showMsg("請輸入國字和注音（注音中間用空格分開）。");
            return;
          }
          levelInputConfig[currentLevelIndex] = { word: w, zhuyin: z };
          rebuildLevelsAndStay(currentLevelIndex);
        });
      }

      if (cfgAddBtn) {
        cfgAddBtn.addEventListener('click', function () {
          const w = (wordInput.value || "").trim();
          const z = (zhuyinInput.value || "").trim();
          if (!w || !z) {
            showMsg("請輸入國字和注音（注音中間用空格分開）。");
            return;
          }
          levelInputConfig.push({ word: w, zhuyin: z });
          rebuildLevelsAndStay(levelInputConfig.length - 1);
        });
      }
    });
  </script>
</body>
</html>
