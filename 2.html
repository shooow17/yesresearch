<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ³¨éŸ³ç¬¦è™Ÿå¤§å†’éšª (è€å¸«å‡ºé¡Œç‰ˆ)</title>
    
    <!-- å¼•å…¥ React æ ¸å¿ƒ -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- å¼•å…¥ Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- å¼•å…¥ Blockly -->
    <script src="https://unpkg.com/blockly@9.3.3/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly@9.3.3/blocks_compressed.js"></script>
    <script src="https://unpkg.com/blockly@9.3.3/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly@9.3.3/msg/zh-hant.js"></script>

    <!-- æ¨£å¼è¨­å®š -->
    <style>
        body { font-family: "Microsoft JhengHei", "Noto Sans TC", sans-serif; }
        
        /* ç©æœ¨å€ (Toolbox) - ä¸Šæ–¹ 40% */
        .blocklyToolboxDiv { 
            background-color: #f1f5f9 !important;
            border-bottom: 2px solid #94a3b8 !important;
            height: 40% !important;
            width: 100% !important;
            box-sizing: border-box;
            padding: 10px;
            padding-top: 36px;
            overflow-y: auto !important;
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
        }
        
        .blocklyFlyout { transform: scale(0.9); }

        /* ç¨‹å¼å€ (Workspace) - ä¸‹æ–¹ */
        .blocklySvg {
            background-color: #ffffff !important;
            height: 100% !important;
            position: absolute;
            top: 0;
        }
        
        .blocklyMainBackground { stroke: none !important; }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden h-screen w-screen">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- SVG Icons ---
        const IconPlay = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
        const IconRotate = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>;
        const IconCheck = () => <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#4ade80" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>;
        const IconAlert = () => <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#f87171" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>;
        const IconCode = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>;
        const IconCube = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>;
        const IconEdit = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>;
        const IconClose = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>;

        // --- é è¨­é—œå¡è³‡æ–™ ---
        const INITIAL_LEVELS = [
            {
                targetChar: "é †",
                targetZhuyin: ["ã„•", "ã„¨", "ã„£", "Ë‹"],
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 10, 1, 1, 1, 1], 
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 11, 1, 1, 1, 1, 1, 12, 1], 
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 13, 1, 1, 1, 1], 
                    [1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                itemMapping: { 10: "ã„•", 11: "ã„¨", 12: "ã„£", 13: "Ë‹" },
                start: { x: 4, z: 4, dir: 0 }, 
            }
        ];

        const ZhuyinGame = () => {
            const [isLibrariesLoaded, setIsLibrariesLoaded] = useState(false);
            const [gameState, setGameState] = useState('IDLE');
            const [failReason, setFailReason] = useState('');
            const [levels, setLevels] = useState(INITIAL_LEVELS);
            const [currentLevel, setCurrentLevel] = useState(0);
            const [collectedSymbols, setCollectedSymbols] = useState([]);
            
            // è€å¸«æ¨¡å¼ç‹€æ…‹
            const [showTeacherModal, setShowTeacherModal] = useState(false);
            const [newLevelChar, setNewLevelChar] = useState('');
            const [newLevelZhuyin, setNewLevelZhuyin] = useState('');
            
            const blocklyDiv = useRef(null);
            const workspaceRef = useRef(null);
            const canvasRef = useRef(null);
            const mountRef = useRef(null);
            
            const sceneRef = useRef(null);
            const playerRef = useRef(null); 
            const playerLimbsRef = useRef({ armL: null, armR: null, legL: null, legR: null });
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const itemsRef = useRef([]); 
            const shadowsRef = useRef([]); 
            
            const playerState = useRef({ x: 0, z: 0, dir: 0 }); 
            const levelData = useRef(null);

            // --- ç”¢ç”Ÿéš¨æ©Ÿåœ°åœ– (è€å¸«æ¨¡å¼æ ¸å¿ƒ) ---
            const generateRandomLevel = (char, zhuyinStr) => {
                const zhuyinList = zhuyinStr.trim().split(/\s+/);
                if (zhuyinList.length === 0 || !char) return null;

                // 9x9 å…¨è‰åœ°
                const newMap = Array(9).fill().map(() => Array(9).fill(1));
                const itemMapping = {};
                
                // æ‰¾å‡ºæ‰€æœ‰å¯ç”¨ä½ç½® (æ’é™¤ä¸­å¿ƒ 4,4)
                const availableSpots = [];
                for(let x=0; x<9; x++){
                    for(let z=0; z<9; z++){
                        if(x !== 4 || z !== 4) availableSpots.push({x, z});
                    }
                }

                // éš¨æ©Ÿæ´—ç‰Œ
                for (let i = availableSpots.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableSpots[i], availableSpots[j]] = [availableSpots[j], availableSpots[i]];
                }

                // åˆ†é…ä½ç½®
                zhuyinList.forEach((z, idx) => {
                    if(idx < availableSpots.length) {
                        const spot = availableSpots[idx];
                        const code = 10 + idx; // ID å¾ 10 é–‹å§‹
                        newMap[spot.z][spot.x] = code;
                        itemMapping[code] = z;
                    }
                });

                return {
                    targetChar: char,
                    targetZhuyin: zhuyinList,
                    map: newMap,
                    itemMapping: itemMapping,
                    start: { x: 4, z: 4, dir: 0 }
                };
            };

            const handleAddLevel = () => {
                const newLevel = generateRandomLevel(newLevelChar, newLevelZhuyin);
                if (newLevel) {
                    const newLevels = [...levels, newLevel];
                    setLevels(newLevels);
                    setCurrentLevel(newLevels.length - 1); // è·³è½‰åˆ°æ–°é—œå¡
                    setGameState('IDLE');
                    setShowTeacherModal(false);
                    setNewLevelChar('');
                    setNewLevelZhuyin('');
                } else {
                    alert("è«‹è¼¸å…¥å®Œæ•´çš„åœ‹å­—èˆ‡æ³¨éŸ³ç¬¦è™Ÿï¼");
                }
            };

            const registerBlocklyDefinitions = () => {
                if (!window.Blockly || !window.Blockly.JavaScript) return;

                const blocks = ['mc_move', 'mc_turn_left', 'mc_turn_right'];
                const titles = { 'mc_move': 'å‰é€²ä¸€æ ¼', 'mc_turn_left': 'å·¦è½‰ â†º', 'mc_turn_right': 'å³è½‰ â†»' };

                blocks.forEach(blockName => {
                    if (!window.Blockly.Blocks[blockName]) {
                        window.Blockly.Blocks[blockName] = {
                            init: function() {
                                this.appendDummyInput().appendField(titles[blockName]);
                                this.setPreviousStatement(true, null);
                                this.setNextStatement(true, null);
                                this.setColour(160);
                            }
                        };
                    }
                });

                const genCode = {
                    'mc_move': 'commands.push("MOVE");\n',
                    'mc_turn_left': 'commands.push("LEFT");\n',
                    'mc_turn_right': 'commands.push("RIGHT");\n'
                };

                Object.keys(genCode).forEach(key => {
                    const func = () => genCode[key];
                    window.Blockly.JavaScript[key] = func;
                    if (window.Blockly.JavaScript.forBlock) {
                        window.Blockly.JavaScript.forBlock[key] = func;
                    }
                });
            };

            useEffect(() => {
                const checkLoaded = setInterval(() => {
                    if (window.THREE && window.Blockly && window.Blockly.JavaScript) {
                        clearInterval(checkLoaded);
                        setIsLibrariesLoaded(true);
                    }
                }, 100);
                return () => clearInterval(checkLoaded);
            }, []);

            const initScene = useCallback(() => {
                if (!canvasRef.current || !window.THREE) return;
                const THREE = window.THREE;

                const width = canvasRef.current.clientWidth;
                const height = canvasRef.current.clientHeight;
                
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); 
                scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

                const camera = new THREE.PerspectiveCamera(40, width / height, 0.1, 100);
                camera.position.set(0, 20, 12); 
                camera.lookAt(0, 0, 1);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ canvas: canvasRef.current, antialias: true, alpha: false });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                rendererRef.current = renderer;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(20, 30, 20);
                dirLight.castShadow = true;
                scene.add(dirLight);

                sceneRef.current = scene;

                const animate = () => {
                    if (!mountRef.current) return;
                    requestAnimationFrame(animate);
                    itemsRef.current.forEach((item, idx) => {
                        if (item.mesh.visible) {
                            item.mesh.position.y = 1.3 + Math.sin(Date.now() * 0.003 + idx) * 0.1;
                        }
                    });
                    renderer.render(scene, camera);
                };
                mountRef.current = true;
                animate();
            }, []);

            const createMultiVoxel = (top, side, bottom, x, y, z) => {
                const THREE = window.THREE;
                const geo = new THREE.BoxGeometry(1, 1, 1);
                const mats = [
                    new THREE.MeshStandardMaterial({ color: side }), 
                    new THREE.MeshStandardMaterial({ color: side }), 
                    new THREE.MeshStandardMaterial({ color: top }),  
                    new THREE.MeshStandardMaterial({ color: bottom }), 
                    new THREE.MeshStandardMaterial({ color: side }), 
                    new THREE.MeshStandardMaterial({ color: side }) 
                ];
                const mesh = new THREE.Mesh(geo, mats);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                const edges = new THREE.EdgesGeometry(geo);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true }));
                mesh.add(line);
                return mesh;
            };

            const createZhuyin3D = (char) => {
                const THREE = window.THREE;
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, 128, 128);
                ctx.font = 'bold 110px "Microsoft JhengHei", sans-serif';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 10; 
                ctx.strokeText(char, 64, 64);
                ctx.fillStyle = '#00FFFF'; ctx.fillText(char, 64, 64);
                const texture = new THREE.CanvasTexture(canvas);
                const geometry = new THREE.BoxGeometry(1.3, 1.3, 0.05);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.FrontSide, depthWrite: false });
                return new THREE.Mesh(geometry, material);
            };

            const createShadowPlane = () => {
                const THREE = window.THREE;
                const geometry = new THREE.PlaneGeometry(0.8, 0.8);
                const material = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.4, side: THREE.FrontSide });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                return mesh;
            };

            const createVoxel = (color, x, y, z, sx, sy, sz) => {
                const THREE = window.THREE;
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), new THREE.MeshStandardMaterial({ color }));
                mesh.position.set(x, y, z);
                mesh.castShadow = true; mesh.receiveShadow = true;
                return mesh;
            };

            const buildLevel = useCallback((levelIndex) => {
                if (!sceneRef.current || !window.THREE) return;
                const THREE = window.THREE;
                const scene = sceneRef.current;

                for(let i = scene.children.length - 1; i >= 0; i--) { 
                    if(scene.children[i].type !== "DirectionalLight" && scene.children[i].type !== "AmbientLight") {
                        scene.remove(scene.children[i]); 
                    }
                }

                // å®‰å…¨æª¢æŸ¥ï¼Œé˜²æ­¢é—œå¡ç´¢å¼•è¶Šç•Œ
                const safeIndex = Math.min(levelIndex, levels.length - 1);
                const data = levels[safeIndex];
                
                levelData.current = JSON.parse(JSON.stringify(data)); 
                playerState.current = { ...data.start };
                setCollectedSymbols([]);
                setFailReason('');
                itemsRef.current = [];
                shadowsRef.current = [];

                const mapGroup = new THREE.Group();
                const offsetX = -(data.map[0].length * 1) / 2;
                const offsetZ = -(data.map.length * 1) / 2;

                data.map.forEach((row, z) => {
                    row.forEach((cell, x) => {
                        const posX = (x * 1) + offsetX;
                        const posZ = (z * 1) + offsetZ;
                        if (cell > 0) {
                            const grass = createMultiVoxel(0x4C9131, 0x724C30, 0x724C30, posX, -0.5, posZ);
                            mapGroup.add(grass);
                        }
                        if (data.itemMapping && data.itemMapping[cell]) {
                            const char = data.itemMapping[cell];
                            const mesh = createZhuyin3D(char);
                            mesh.position.set(posX, 1.3, posZ); 
                            mesh.rotation.x = -Math.PI / 3.5; 
                            scene.add(mesh);
                            const shadow = createShadowPlane();
                            shadow.position.set(posX, 0.02, posZ);
                            scene.add(shadow);
                            shadowsRef.current.push(shadow);
                            itemsRef.current.push({ mesh, shadow, symbol: char, gridX: x, gridZ: z, collected: false });
                        }
                    });
                });
                scene.add(mapGroup);

                const steveGroup = new THREE.Group();
                const skin = 0xCF9E7A, hair = 0x3A2208;
                const head = new THREE.Group();
                head.position.y = 1.5;
                head.add(createVoxel(skin, 0, 0, 0, 0.4, 0.4, 0.4));
                head.add(createVoxel(hair, 0, 0.21, 0, 0.42, 0.05, 0.42)); 
                head.add(createVoxel(hair, 0, 0.1, -0.21, 0.42, 0.2, 0.05));
                head.add(createVoxel(hair, -0.21, 0.1, 0, 0.05, 0.2, 0.4));
                head.add(createVoxel(hair, 0.21, 0.1, 0, 0.05, 0.2, 0.4));
                const fz = 0.205;
                head.add(createVoxel(0xFFFFFF, 0.1, 0.05, fz, 0.1, 0.05, 0.02)); 
                head.add(createVoxel(0x2222FF, 0.12, 0.05, fz+0.001, 0.05, 0.05, 0.02)); 
                head.add(createVoxel(0xFFFFFF, -0.1, 0.05, fz, 0.1, 0.05, 0.02)); 
                head.add(createVoxel(0x2222FF, -0.12, 0.05, fz+0.001, 0.05, 0.05, 0.02)); 
                head.add(createVoxel(0xB87E6A, 0, -0.05, fz, 0.08, 0.05, 0.02)); 
                head.add(createVoxel(0x9E6A4A, 0, -0.12, fz, 0.2, 0.06, 0.02)); 
                steveGroup.add(head);
                steveGroup.add(createVoxel(0x009999, 0, 0.9, 0, 0.4, 0.6, 0.2)); 
                const mkLimb = (x, y, c, w, h, d, isLeg) => {
                    const g = new THREE.Group();
                    g.position.set(x, y, 0);
                    g.add(createVoxel(c, 0, -h/2 + (isLeg?0:0.1), 0, w, h, d));
                    steveGroup.add(g);
                    return g;
                };
                playerLimbsRef.current.armL = mkLimb(-0.3, 1.1, skin, 0.18, 0.6, 0.18, false);
                playerLimbsRef.current.armR = mkLimb(0.3, 1.1, skin, 0.18, 0.6, 0.18, false);
                playerLimbsRef.current.legL = mkLimb(-0.1, 0.6, 0x0000AA, 0.18, 0.6, 0.18, true);
                playerLimbsRef.current.legR = mkLimb(0.1, 0.6, 0x0000AA, 0.18, 0.6, 0.18, true);
                scene.add(steveGroup);
                playerRef.current = steveGroup;

                updatePlayerTransform(data.start.x, data.start.z, data.start.dir, offsetX, offsetZ);

            }, [levels]); // ä¾è³´ levelsï¼Œå› ç‚ºç¾åœ¨ levels æ˜¯å‹•æ…‹çš„

            const updatePlayerTransform = (gridX, gridZ, dirIndex, offX, offZ) => {
                if (!playerRef.current) return;
                playerRef.current.position.set((gridX * 1) + offX, 0, (gridZ * 1) + offZ);
                const rots = [Math.PI, Math.PI/2, 0, -Math.PI/2];
                playerRef.current.rotation.y = rots[dirIndex];
                Object.values(playerLimbsRef.current).forEach(l => { if(l) l.rotation.x = 0; });
            };

            useEffect(() => {
                if (!isLibrariesLoaded || !blocklyDiv.current) return;
                
                initScene();
                buildLevel(currentLevel); // ä½¿ç”¨ currentLevel
                registerBlocklyDefinitions();

                const Blockly = window.Blockly;
                if (workspaceRef.current) workspaceRef.current.dispose();

                workspaceRef.current = Blockly.inject(blocklyDiv.current, {
                    toolbox: `
                    <xml>
                        <block type="mc_move"></block>
                        <block type="mc_turn_left"></block>
                        <block type="mc_turn_right"></block>
                        <block type="controls_repeat_ext">
                            <value name="TIMES"><shadow type="math_number"><field name="NUM">4</field></shadow></value>
                        </block>
                    </xml>`,
                    scrollbars: true, 
                    trashcan: true,
                    zoom: { startScale: 1.0, maxScale: 3, minScale: 0.8, scaleSpeed: 1.2 },
                    theme: { 'componentStyles': { 'workspaceBackgroundColour': '#ffffff', 'toolboxBackgroundColour': '#f1f5f9' } }
                });

                const observer = new ResizeObserver(() => Blockly.svgResize(workspaceRef.current));
                observer.observe(blocklyDiv.current);
                return () => observer.disconnect();

            }, [isLibrariesLoaded, initScene]); 

            // ç•¶é—œå¡æ”¹è®Šæ™‚ï¼Œé‡å»ºå ´æ™¯
            useEffect(() => {
                if (isLibrariesLoaded) { buildLevel(currentLevel); }
            }, [currentLevel, isLibrariesLoaded, buildLevel]);

            const runCode = async () => {
                if (gameState === 'RUNNING') return;
                
                registerBlocklyDefinitions(); 
                if (!window.Blockly || !window.Blockly.JavaScript) {
                    alert("Blockly å°šæœªè¼‰å…¥å®Œæˆ"); return;
                }

                setGameState('RUNNING');
                setFailReason('');
                
                const data = levelData.current;
                const offX = -(data.map[0].length)/2;
                const offZ = -(data.map.length)/2;
                playerState.current = { ...data.start };
                updatePlayerTransform(data.start.x, data.start.z, data.start.dir, offX, offZ);
                setCollectedSymbols([]);
                itemsRef.current.forEach(i => { 
                    i.mesh.visible = true; 
                    i.shadow.visible = true;
                    i.collected = false; 
                    i.mesh.material.color.setHex(0xffffff); 
                });

                let code = '';
                try {
                    window.Blockly.JavaScript.init(workspaceRef.current);
                    code = window.Blockly.JavaScript.workspaceToCode(workspaceRef.current);
                } catch (e) {
                    setFailReason("ç¨‹å¼ç¢¼éŒ¯èª¤ï¼š" + e.message);
                    setGameState('FAIL');
                    return;
                }

                const commands = [];
                try {
                    new Function('commands', code)(commands);
                } catch (e) {
                    setGameState('FAIL');
                    return;
                }

                let currentCollected = [];
                for (let cmd of commands) {
                    if (!mountRef.current) break;
                    let { x, z, dir } = playerState.current;
                    let fail = false;

                    if (cmd === 'LEFT') {
                        dir = (dir + 3) % 4; playerState.current.dir = dir;
                        await animateTurn(Math.PI / 2);
                    } else if (cmd === 'RIGHT') {
                        dir = (dir + 1) % 4; playerState.current.dir = dir;
                        await animateTurn(-Math.PI / 2);
                    } else if (cmd === 'MOVE') {
                        let nx = x, nz = z;
                        if (dir === 0) nz -= 1; if (dir === 1) nx += 1; if (dir === 2) nz += 1; if (dir === 3) nx -= 1;

                        if (nz >= 0 && nz < data.map.length && nx >= 0 && nx < data.map[0].length && data.map[nz][nx] !== 0) {
                            playerState.current.x = nx; playerState.current.z = nz;
                            await animateMove(nx, nz, offX, offZ);
                            
                            const idx = itemsRef.current.findIndex(i => i.gridX === nx && i.gridZ === nz && !i.collected);
                            if (idx !== -1) {
                                const item = itemsRef.current[idx];
                                const expected = data.targetZhuyin[currentCollected.length];
                                if (item.symbol === expected) {
                                    item.mesh.visible = false; 
                                    item.shadow.visible = false;
                                    item.collected = true;
                                    currentCollected.push(item.symbol);
                                    setCollectedSymbols([...currentCollected]);
                                } else {
                                    setFailReason(`é †åºéŒ¯èª¤ï¼æ‡‰å…ˆæ”¶é›†ã€Œ${expected}ã€ï¼Œä½†ä½ ç¢°åˆ°äº†ã€Œ${item.symbol}ã€ã€‚`);
                                    item.mesh.material.color.setHex(0xFF0000);
                                    fail = true;
                                }
                            }
                        } else {
                            setFailReason("æ’ç‰†äº†ï¼");
                            await animateBump();
                            fail = true;
                        }
                    }
                    if (fail) { setGameState('FAIL'); return; }
                    await new Promise(r => setTimeout(r, 200));
                }

                if (currentCollected.length === data.targetZhuyin.length) {
                    setGameState('SUCCESS');
                } else {
                    if (gameState !== 'FAIL') { setFailReason("å°šæœªæ”¶é›†å®Œæ‰€æœ‰æ³¨éŸ³ï¼"); setGameState('FAIL'); }
                }
            };

            const animateTurn = (delta) => new Promise(res => {
                const start = playerRef.current.rotation.y, target = start + delta;
                let p = 0;
                const tick = () => {
                    p++; playerRef.current.rotation.y = start + delta * (p/20);
                    if(p<20) requestAnimationFrame(tick); else { playerRef.current.rotation.y = target; res(); }
                }; tick();
            });

            const animateMove = (nx, nz, offX, offZ) => new Promise(res => {
                const startX = playerRef.current.position.x, startZ = playerRef.current.position.z;
                const targetX = (nx * 1) + offX, targetZ = (nz * 1) + offZ;
                let p = 0;
                const tick = () => {
                    p++; const t = p/30;
                    playerRef.current.position.x = startX + (targetX - startX) * t;
                    playerRef.current.position.z = startZ + (targetZ - startZ) * t;
                    playerRef.current.position.y = Math.sin(t * Math.PI) * 0.5;
                    const ang = Math.sin(t * Math.PI * 2) * 0.5;
                    const { armL, armR, legL, legR } = playerLimbsRef.current;
                    if(armL) armL.rotation.x = ang; if(armR) armR.rotation.x = -ang;
                    if(legL) legL.rotation.x = -ang; if(legR) legR.rotation.x = ang;

                    if(p<30) requestAnimationFrame(tick); else {
                        playerRef.current.position.set(targetX, 0, targetZ);
                        Object.values(playerLimbsRef.current).forEach(l => l.rotation.x = 0);
                        res();
                    }
                }; tick();
            });

            const animateBump = () => new Promise(res => {
                let p = 0;
                const tick = () => {
                    p++; playerRef.current.rotation.z = Math.sin(p) * 0.1;
                    if(p<20) requestAnimationFrame(tick); else { playerRef.current.rotation.z = 0; res(); }
                }; tick();
            });

            const currentData = levels[currentLevel] || levels[0];

            return (
                <div className="flex w-full h-full relative">
                    {/* å·¦å´ï¼šæ“ä½œå€ (1/3) */}
                    <div className="w-1/3 min-w-[320px] h-full flex flex-col border-r border-gray-700 bg-gray-100 relative">
                        {/* æ¨™ç±¤ï¼šç©æœ¨åº« */}
                        <div className="absolute top-0 left-0 right-0 h-9 bg-gray-100 border-b border-gray-300 flex items-center px-4 z-10 pointer-events-none shadow-sm">
                            <span className="text-gray-700 font-bold text-sm flex items-center gap-2">
                                <IconCube /> ç©æœ¨åº« (å¾æ­¤æ‹–æ›³)
                            </span>
                        </div>
                        
                        {/* æ¨™ç±¤ï¼šå·¥ä½œå€ */}
                        <div className="absolute top-[40%] left-0 right-0 h-8 bg-white/90 border-t border-gray-200 flex items-center px-4 z-10 pointer-events-none">
                            <span className="text-gray-500 font-bold text-xs flex items-center gap-2">
                                <IconCode /> å·¥ä½œå€ (åœ¨æ­¤çµ„åˆç¨‹å¼)
                            </span>
                        </div>

                        <div className="flex-1 relative">
                            <div ref={blocklyDiv} className="absolute inset-0" />
                            {!isLibrariesLoaded && <div className="absolute inset-0 flex items-center justify-center bg-white/80 z-20 text-black font-bold">è³‡æºè¼‰å…¥ä¸­...</div>}
                        </div>
                    </div>

                    {/* å³å´ï¼šéŠæˆ²å€ (2/3) */}
                    <div className="flex-1 flex flex-col bg-gray-900 relative">
                        <header className="bg-emerald-600 p-4 shadow-lg flex justify-between items-center z-10 h-16 shrink-0">
                            <div className="flex items-center gap-4">
                                <div className="bg-white text-emerald-700 w-12 h-12 flex items-center justify-center rounded-lg font-bold text-3xl shadow">
                                    {currentData.targetChar}
                                </div>
                                <div>
                                    <h1 className="text-xl font-bold">æ³¨éŸ³å¤§å†’éšª</h1>
                                    <div className="flex gap-1 mt-1">
                                        {currentData.targetZhuyin.map((c, i) => (
                                            <span key={i} className={`w-8 h-8 flex items-center justify-center rounded border-2 font-bold text-lg ${collectedSymbols.length > i ? 'bg-yellow-400 text-black border-yellow-500' : 'bg-black/20 text-white/30 border-white/20'}`}>{c}</span>
                                        ))}
                                    </div>
                                </div>
                            </div>
                            <div className="flex items-center gap-2">
                                {/* è€å¸«æ¨¡å¼æŒ‰éˆ• */}
                                <button onClick={() => setShowTeacherModal(true)} className="flex items-center gap-1 bg-white/10 hover:bg-white/20 text-white px-3 py-1.5 rounded-lg text-sm transition-colors mr-2">
                                    <IconEdit /> å‡ºé¡Œ
                                </button>

                                <span className="bg-black/20 px-3 py-1 rounded text-sm text-white/80">é—œå¡ {currentLevel + 1}/{levels.length}</span>
                                <button onClick={runCode} disabled={gameState === 'RUNNING' || !isLibrariesLoaded} className={`flex items-center gap-2 px-6 py-2 rounded-lg font-bold shadow transition-transform active:scale-95 ${gameState === 'RUNNING' ? 'bg-gray-500' : 'bg-orange-500 hover:bg-orange-600'}`}>
                                    <IconPlay /> {gameState === 'RUNNING' ? 'åŸ·è¡Œä¸­...' : 'é–‹å§‹æ‹¼éŸ³'}
                                </button>
                            </div>
                        </header>

                        <canvas ref={canvasRef} className="flex-1 block w-full outline-none" />

                        {/* ç‹€æ…‹ Overlay */}
                        {gameState === 'IDLE' && (
                            <div className="absolute bottom-4 right-4 bg-black/60 p-4 rounded-lg text-right pointer-events-none backdrop-blur-sm">
                                <p className="text-gray-300 text-sm mb-1">ç›®æ¨™ï¼šä¾ç…§é †åºæ”¶é›†</p>
                                <div className="flex justify-end gap-2">
                                    {currentData.targetZhuyin.map((z, i) => <span key={i} className="text-yellow-400 font-bold text-xl">{z}</span>)}
                                </div>
                            </div>
                        )}

                        {gameState === 'SUCCESS' && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20">
                                <IconCheck />
                                <h2 className="text-4xl font-bold text-white mt-4 mb-2">æ‹¼éŸ³æˆåŠŸï¼</h2>
                                <p className="text-gray-300 mb-8">å¤ªæ£’äº†ï¼ä½ å®Œæˆäº†ã€Œ{currentData.targetChar}ã€çš„æ‹¼éŸ³ã€‚</p>
                                {currentLevel < levels.length - 1 ? (
                                    <button onClick={() => { setCurrentLevel(c => c+1); setGameState('IDLE'); }} className="bg-green-600 hover:bg-green-500 text-white px-8 py-3 rounded-xl font-bold text-xl shadow-lg">ä¸‹ä¸€é—œ âœ</button>
                                ) : (
                                    <div className="text-yellow-400 text-2xl font-bold">ğŸ‰ å…¨æ•¸é€šé—œï¼å¤ªå²å®³äº†ï¼</div>
                                )}
                            </div>
                        )}

                        {gameState === 'FAIL' && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20">
                                <div className="bg-gray-800 p-8 rounded-2xl border-2 border-red-500 text-center max-w-md shadow-2xl">
                                    <div className="flex justify-center mb-4"><IconAlert /></div>
                                    <h3 className="text-2xl font-bold text-white mb-2">å¤±æ•—äº†...</h3>
                                    <p className="text-red-300 mb-6 text-lg">{failReason}</p>
                                    <button onClick={() => { setGameState('IDLE'); buildLevel(currentLevel); }} className="bg-white/10 hover:bg-white/20 text-white px-6 py-2 rounded-lg flex items-center gap-2 mx-auto">
                                        <IconRotate /> å†è©¦ä¸€æ¬¡
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* è€å¸«å‡ºé¡Œ Modal */}
                    {showTeacherModal && (
                        <div className="absolute inset-0 z-50 bg-black/80 flex items-center justify-center">
                            <div className="bg-white text-gray-900 p-8 rounded-2xl shadow-2xl max-w-md w-full relative">
                                <button onClick={() => setShowTeacherModal(false)} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600">
                                    <IconClose />
                                </button>
                                <h2 className="text-2xl font-bold mb-6 text-emerald-700 flex items-center gap-2">
                                    <IconEdit /> è€å¸«å‡ºé¡Œæ¨¡å¼
                                </h2>
                                
                                <div className="space-y-4">
                                    <div>
                                        <label className="block text-sm font-bold text-gray-700 mb-1">ç›®æ¨™åœ‹å­—</label>
                                        <input 
                                            type="text" 
                                            maxLength="1"
                                            placeholder="ä¾‹å¦‚ï¼šè²“" 
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 outline-none text-lg"
                                            value={newLevelChar}
                                            onChange={e => setNewLevelChar(e.target.value)}
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-bold text-gray-700 mb-1">æ³¨éŸ³ç¬¦è™Ÿ (è«‹ç”¨ç©ºç™½åˆ†é–‹)</label>
                                        <input 
                                            type="text" 
                                            placeholder="ä¾‹å¦‚ï¼šã„‡ ã„ " 
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500 outline-none text-lg"
                                            value={newLevelZhuyin}
                                            onChange={e => setNewLevelZhuyin(e.target.value)}
                                        />
                                        <p className="text-xs text-gray-500 mt-1">ç³»çµ±å°‡è‡ªå‹•ç”¢ç”Ÿ 9x9 åœ°åœ–ä¸¦éš¨æ©Ÿé…ç½®ç¬¦è™Ÿä½ç½®ã€‚</p>
                                    </div>
                                    
                                    <button 
                                        onClick={handleAddLevel}
                                        className="w-full bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 rounded-lg shadow-lg transition-transform active:scale-95 mt-4"
                                    >
                                        ç”Ÿæˆä¸¦é–‹å§‹éŠç©
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ZhuyinGame />);
    </script>
</body>
</html>
