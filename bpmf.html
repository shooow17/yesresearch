<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="utf-8" />
  <title>æ³¨éŸ³éº¥å¡Šå°éŠæˆ²ï¼ˆBlockly + Three.jsï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- Tailwindï¼ˆç´”æ’ç‰ˆï¼‰ -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- Blockly -->
  <script src="https://unpkg.com/blockly@9.3.3/blockly_compressed.js"></script>
  <script src="https://unpkg.com/blockly@9.3.3/blocks_compressed.js"></script>
  <script src="https://unpkg.com/blockly@9.3.3/javascript_compressed.js"></script>
  <script src="https://unpkg.com/blockly@9.3.3/msg/zh-hant.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Microsoft JhengHei", "Noto Sans TC", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      touch-action: none;
    }

    #blocklyDiv {
      width: 100%;
      height: 100%;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      outline: none;
    }

    .blocklyToolboxDiv {
      background-color: #f8fafc !important;
      /* æ”¹ç‚ºä¸Šä¸‹åˆ†å‰²æ™‚ï¼Œå·¥å…·ç®±æ”¹ç”¨ä¸‹é‚Šæ¡† */
      border-bottom: 1px solid #cbd5f5 !important;
      border-right: none !important;
      box-sizing: border-box;
    }
    .blocklySvg {
      background-color: #ffffff !important;
    }
    .blocklyMainBackground {
      stroke: none !important;
    }
    
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 3px;}
    .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px;}
    .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
  </style>
</head>
<body class="bg-slate-900 text-white fixed inset-0">
  
  <!-- ä¸»è¦å®¹å™¨ -->
  <div class="flex flex-col md:flex-row w-full h-screen overflow-hidden">
    
    <!-- å€åŸŸ 1ï¼šéŠæˆ²ç•«é¢ -->
    <div class="relative w-full h-[40vh] md:h-full md:flex-1 order-1 md:order-2 z-0 bg-sky-300 min-w-0">
      <canvas id="gameCanvas"></canvas>

      <!-- è³‡è¨Šé¢æ¿ -->
      <div id="info"
           class="absolute top-2 left-2 md:top-4 md:left-4 bg-black/70 text-xs md:text-lg px-2 py-2 md:px-5 md:py-4 rounded-lg pointer-events-auto z-10 shadow-lg max-w-[220px] md:max-w-md transition-all duration-300">
        
        <div class="flex justify-between items-center mb-1 md:mb-2">
           <span class="font-bold text-emerald-400 text-xs md:text-lg">é—œå¡è³‡è¨Š</span>
           <button id="toggleInfoBtn" class="text-white/80 hover:text-white focus:outline-none ml-2 p-1 rounded hover:bg-white/10">
             <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 md:h-6 md:w-6 transition-transform duration-300" id="toggleIcon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
               <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" />
             </svg>
           </button>
        </div>

        <div id="infoBody" class="transition-all duration-300 overflow-hidden">
          <div class="space-y-1 md:space-y-2">
            <div id="wordInfo" class="font-bold text-yellow-300">åœ‹å­—ï¼š</div>
            <div id="zhuyinInfo" class="font-semibold">æ³¨éŸ³ï¼š</div>
            <div id="collectedInfo" class="text-slate-200 text-[10px] md:text-base">ç›®å‰æ”¶é›†ï¼šå°šæœªæ”¶é›†</div>
          </div>

          <div class="flex items-center gap-1 md:gap-3 pt-2 md:pt-3 mt-2 md:mt-3 border-t border-white/30">
            <button id="prevLevelBtn"
                    class="px-2 py-1 md:px-3 md:py-1.5 rounded bg-white/10 text-[10px] md:text-base hover:bg-white/20 disabled:opacity-40 disabled:hover:bg-white/10 transition">
              â—€
            </button>
            <div id="levelInfo" class="text-[10px] md:text-base font-medium whitespace-nowrap">
              1 / 1
            </div>
            <button id="nextLevelBtn"
                    class="px-2 py-1 md:px-3 md:py-1.5 rounded bg-white/10 text-[10px] md:text-base hover:bg-white/20 disabled:opacity-40 disabled:hover:bg-white/10 transition">
              â–¶
            </button>
          </div>

          <details class="mt-2 md:mt-3 bg-black/40 rounded px-2 py-1 md:px-3 md:py-2 text-[10px] md:text-base">
            <summary class="cursor-pointer select-none font-medium text-slate-300 hover:text-white">
              ç·¨è¼¯
            </summary>
            <div class="mt-2 space-y-2">
              <div class="flex items-center gap-1 md:gap-2">
                <span class="shrink-0">åœ‹å­—</span>
                <input id="cfgWordInput"
                       class="w-14 md:w-28 px-1 md:px-2 py-0.5 md:py-1 rounded bg-white/90 text-slate-900 outline-none focus:ring-2 focus:ring-emerald-500" />
              </div>
              <div class="flex items-center gap-1 md:gap-2">
                <span class="shrink-0">æ³¨éŸ³</span>
                <input id="cfgZhuyinInput"
                       placeholder="ä¾‹ï¼šã„• ã„¨ ã„£ Ë‹"
                       class="w-20 md:w-40 px-1 md:px-2 py-0.5 md:py-1 rounded bg-white/90 text-slate-900 outline-none focus:ring-2 focus:ring-emerald-500" />
              </div>
              <div class="flex gap-1 md:gap-2 pt-1">
                <button id="cfgApplyCurrent"
                        class="flex-1 px-1 md:px-2 py-1 rounded bg-emerald-500 text-white hover:bg-emerald-600 transition shadow">
                  æ›´æ–°
                </button>
                <button id="cfgAddLevel"
                        class="flex-1 px-1 md:px-2 py-1 rounded bg-sky-500 text-white hover:bg-sky-600 transition shadow">
                  æ–°å¢
                </button>
              </div>
            </div>
          </details>
        </div>
      </div>

      <div id="status"
           class="absolute bottom-2 left-2 right-2 md:bottom-3 md:left-3 md:right-auto bg-black/60 text-xs md:text-sm px-3 py-2 rounded-md pointer-events-none z-10 text-center md:text-left">
        æç¤ºï¼šçµ„ç¨‹å¼ï¼ŒæŒ‰åŸ·è¡Œã€‚
      </div>
    </div>

    <!-- å€åŸŸ 2ï¼šBlockly æ§åˆ¶å€ -->
    <div class="relative w-full h-[60vh] md:h-full md:w-1/3 min-w-0 md:min-w-[320px] bg-slate-100 text-slate-900 flex flex-col border-t-2 md:border-t-0 md:border-r border-slate-400 order-2 md:order-1 z-10">
      <div class="px-4 py-2 border-b border-slate-300 bg-slate-50 flex items-center justify-between shrink-0">
        <div class="font-semibold text-slate-700">ç¨‹å¼ç©æœ¨</div>
        <div class="text-xs text-slate-500">æ‹–æ›³ç©æœ¨æ§åˆ¶</div>
      </div>
      <!-- ç©æœ¨å€å®¹å™¨ -->
      <div class="flex-1 relative w-full min-h-0 bg-white" id="blocklyArea">
        <div id="blocklyDiv" class="absolute inset-0"></div>
      </div>
      <div class="px-4 py-3 border-t border-slate-300 bg-slate-50 flex gap-2 shrink-0">
        <!-- ä¿®æ”¹ï¼šåŸ·è¡ŒæŒ‰éˆ• -->
        <button id="runBtn"
                class="flex-1 px-4 py-3 rounded-lg bg-emerald-600 text-white text-lg font-bold hover:bg-emerald-700 active:scale-95 transition shadow-md">
          â–¶ åŸ·è¡Œç¨‹å¼
        </button>
        <!-- ä¿®æ”¹ï¼šé‡è¨­æŒ‰éˆ• (åŠ å¤§ã€æ›´æ˜é¡¯) -->
        <button id="resetBtn"
                class="px-6 py-3 rounded-lg bg-orange-500 text-white text-lg font-bold hover:bg-orange-600 active:scale-95 transition shadow-md flex items-center gap-1">
          âŸ³ é‡è¨­
        </button>
      </div>
    </div>

  </div>

  <!-- æ”¶é›†å®Œæˆå°è©±æ¡† -->
  <div id="completeDialog"
       class="hidden fixed inset-0 flex items-center justify-center bg-black/60 z-50 px-4">
    <div class="bg-white text-slate-900 rounded-xl shadow-xl px-6 py-5 w-80 max-w-full text-center">
      <div id="dialogTitle" class="text-xl font-bold mb-3 text-emerald-600">å¤ªæ£’äº†ï¼</div>
      <div id="dialogMessage" class="text-base mb-6 text-slate-600">
        ä½ å®Œæˆäº†é—œå¡ã€‚
      </div>
      <div class="flex justify-center gap-3">
        <button id="dialogRestartBtn"
                class="flex-1 px-4 py-2 rounded-lg bg-slate-200 text-slate-700 font-semibold hover:bg-slate-300">
          é‡ç©
        </button>
        <button id="dialogNextBtn"
                class="flex-1 px-4 py-2 rounded-lg bg-emerald-500 text-white font-semibold hover:bg-emerald-600 shadow-md">
          ä¸‹ä¸€é—œ
        </button>
      </div>
    </div>
  </div>

  <!-- ä¸€èˆ¬è¨Šæ¯/è¨ºæ–·å°è©±æ¡† -->
  <div id="msgDialog" class="hidden fixed inset-0 flex items-center justify-center bg-black/60 z-50 px-4">
    <div class="bg-white text-slate-900 rounded-xl shadow-xl px-6 py-5 w-96 max-w-full text-center flex flex-col max-h-[80vh]">
      <div id="msgTitle" class="text-lg font-bold mb-3 text-emerald-700 border-b pb-2 shrink-0">æç¤º</div>
      <div id="msgDialogText" class="text-sm mb-5 text-slate-700 leading-relaxed text-left bg-slate-50 p-4 rounded-md border border-slate-200 overflow-y-auto flex-1 custom-scrollbar"></div>
      <button onclick="document.getElementById('msgDialog').classList.add('hidden')" class="w-full px-4 py-2 rounded-lg bg-slate-600 text-white text-sm font-semibold hover:bg-slate-700 transition shrink-0">
        çŸ¥é“äº†
      </button>
    </div>
  </div>

  <script>
    // ========= UI Helpers =========
    function showMsg(text, title="æç¤º") {
      const el = document.getElementById('msgDialog');
      const txt = document.getElementById('msgDialogText');
      const titleEl = document.getElementById('msgTitle');
      if (el && txt && titleEl) {
        titleEl.textContent = title;
        txt.innerHTML = text; 
        el.classList.remove('hidden');
      } else {
        console.log(text);
      }
    }

    // ========= ç©æœ¨åœ–ç¤ºç”¢ç”Ÿå™¨ =========
    function createBlockHtml(type) {
      let colorClass = "";
      let text = "";
      
      if (type === 'MOVE') {
        colorClass = "bg-[#009b85] border-[#007a69]"; 
        text = "å‰é€²ä¸€æ ¼";
      } else if (type === 'LEFT') {
        colorClass = "bg-[#00acc1] border-[#008798]";
        text = "å‘å·¦è½‰ â†º";
      } else if (type === 'RIGHT') {
        colorClass = "bg-[#00acc1] border-[#008798]";
        text = "å‘å³è½‰ â†»";
      }

      return `
        <div class="flex justify-center my-1 w-full animate-fade-in">
          <div class="relative flex items-center justify-start px-4 py-2 text-white font-bold rounded shadow-sm ${colorClass} border-l-[6px] border-black/20 w-40 select-none cursor-default">
            <span class="text-sm drop-shadow-md">${text}</span>
            <!-- æ¨¡æ“¬ç©æœ¨å¡æ¦«å‡¹æ§½ -->
            <div class="absolute left-3 -bottom-1.5 w-4 h-2 bg-white/30 rounded-b"></div>
            <div class="absolute left-3 -top-1.5 w-4 h-2 bg-black/10 rounded-t"></div>
          </div>
        </div>
        <!-- é€£æ¥ç®­é ­ -->
        <div class="flex justify-center -my-1 last:hidden opacity-50">
           <div class="text-slate-400 text-[10px]">â–¼</div>
        </div>
      `;
    }

    // ========= æ•™å¸«é è¨­é—œå¡ =========
    let levelInputConfig = [
      { word: "é †", zhuyin: "ã„• ã„¨ ã„£ Ë‹" },
      { word: "åª½", zhuyin: "ã„‡ ã„š ËŠ" },
      { word: "å®¶", zhuyin: "ã„ ã„§ ã„š" }
    ];

    const GRID_SIZE = 9;
    const GRID_OFFSET = Math.floor(GRID_SIZE / 2);
    const DIR_ROTATIONS = [Math.PI, Math.PI / 2, 0, -Math.PI / 2];
    const MAX_ITEMS_PER_LEVEL = 4;

    function getRandomGridPositions(count, bannedSet) {
      const positions = [];
      for (let z = 0; z < GRID_SIZE; z++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const key = x + "," + z;
          if (bannedSet && bannedSet.has(key)) continue;
          positions.push({ x, z });
        }
      }
      if (positions.length <= count) return positions;
      for (let i = positions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = positions[i]; positions[i] = positions[j]; positions[j] = tmp;
      }
      return positions.slice(0, count);
    }

    function buildLevelsFromInput(configList) {
      const levels = [];
      configList.forEach((cfg, idx) => {
        if (!cfg) return;
        const word = cfg.word || ("ç¬¬" + (idx + 1) + "é—œ");
        const zhuyinArr = String(cfg.zhuyin || "").split(/\s+/).map(s => s.trim()).filter(Boolean);
        if (!zhuyinArr.length) return;
        const usedZhuyin = zhuyinArr.slice(0, MAX_ITEMS_PER_LEVEL);
        const map = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(1));
        const itemMapping = {};
        const banned = new Set(); banned.add("4,4");
        const positions = getRandomGridPositions(usedZhuyin.length, banned);
        positions.forEach((pos, i) => {
          const code = 10 + i;
          map[pos.z][pos.x] = code;
          itemMapping[code] = usedZhuyin[i];
        });
        levels.push({ targetChar: word, targetZhuyin: usedZhuyin, map, itemMapping, start: { x: 4, z: 4, dir: 2 } });
      });
      // ä¿åº•
      if (!levels.length) {
        const map = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(1));
        const itemMapping = {};
        const defaultZhuyin = ["ã„•", "ã„¨", "ã„£", "Ë‹"];
        const banned = new Set(); banned.add("4,4");
        const positions = getRandomGridPositions(defaultZhuyin.length, banned);
        positions.forEach((pos, i) => {
          const code = 10 + i;
          map[pos.z][pos.x] = code;
          itemMapping[code] = defaultZhuyin[i];
        });
        levels.push({ targetChar: "é †", targetZhuyin: defaultZhuyin, map, itemMapping, start: { x: 4, z: 4, dir: 2 } });
      }
      return levels;
    }

    let LEVELS = buildLevelsFromInput(levelInputConfig);
    let currentLevelIndex = 0;

    let workspace = null;
    let scene = null;
    let camera = null;
    let renderer = null;
    let levelGroup = null;
    let player = null;
    let playerLimbs = {};
    let tiles = [];
    let items = [];
    let extraPlayers = [];
    let collectedSymbols = [];
    const playerState = { x: 0, z: 0, dir: 0 };

    // ========= UI Updates =========
    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    function updateStatus(text) {
      const el = document.getElementById('status');
      if (el) el.textContent = text;
    }

    function updateCollectedInfo() {
      const el = document.getElementById('collectedInfo');
      if (!el) return;
      if (collectedSymbols.length === 0) el.textContent = "ç›®å‰æ”¶é›†ï¼šå°šæœªæ”¶é›†";
      else el.textContent = "ç›®å‰æ”¶é›†ï¼š" + collectedSymbols.join(" ");
    }

    function updateLevelNavButtons() {
      const prevBtn = document.getElementById('prevLevelBtn');
      const nextBtn = document.getElementById('nextLevelBtn');
      if (prevBtn) prevBtn.disabled = (currentLevelIndex === 0);
      if (nextBtn) nextBtn.disabled = (currentLevelIndex === LEVELS.length - 1);
    }

    function fillLevelFormFromConfig() {
      const wordInput = document.getElementById('cfgWordInput');
      const zhuyinInput = document.getElementById('cfgZhuyinInput');
      if (!wordInput || !zhuyinInput) return;
      const cfg = levelInputConfig[currentLevelIndex];
      if (!cfg) { wordInput.value = ""; zhuyinInput.value = ""; }
      else { wordInput.value = cfg.word || ""; zhuyinInput.value = cfg.zhuyin || ""; }
    }

    function updateLevelInfo() {
      const level = LEVELS[currentLevelIndex];
      const wEl = document.getElementById('wordInfo');
      const zEl = document.getElementById('zhuyinInfo');
      const lEl = document.getElementById('levelInfo');
      if (level) {
        if (wEl) wEl.textContent = "åœ‹å­—ï¼š" + (level.targetChar || "");
        if (zEl) zEl.textContent = "æ³¨éŸ³ï¼š" + level.targetZhuyin.join(" ");
      }
      if (lEl) lEl.textContent = (currentLevelIndex + 1) + " / " + LEVELS.length;
      updateCollectedInfo(); updateLevelNavButtons(); fillLevelFormFromConfig();
    }

    function showCompleteDialog(level) {
      const dialog = document.getElementById('completeDialog');
      const msgEl  = document.getElementById('dialogMessage');
      const nextBtn = document.getElementById('dialogNextBtn');
      if (level && msgEl) msgEl.textContent = "ä½ ç”¨ " + level.targetZhuyin.join(" ") + " çµ„æˆäº†ã€Œ" + level.targetChar + "ã€ï¼";
      if (nextBtn) nextBtn.textContent = (currentLevelIndex === LEVELS.length - 1) ? "é—œé–‰" : "ä¸‹ä¸€é—œ";
      if (dialog) dialog.classList.remove('hidden');
    }

    function hideCompleteDialog() {
      const dialog = document.getElementById('completeDialog');
      if (dialog) dialog.classList.add('hidden');
    }

    function setLevel(index) {
      if (index < 0 || index >= LEVELS.length) return;
      currentLevelIndex = index;
      buildLevel(currentLevelIndex);
      hideCompleteDialog(); updateLevelInfo();
      updateStatus("å·²åˆ‡æ›åˆ°ç¬¬ " + (currentLevelIndex + 1) + " é—œã€‚");
    }

    function rebuildLevelsAndStay(targetIndex) {
      const oldIndex = (typeof targetIndex === "number") ? targetIndex : currentLevelIndex;
      LEVELS = buildLevelsFromInput(levelInputConfig);
      let newIndex = oldIndex;
      if (newIndex < 0) newIndex = 0;
      if (newIndex >= LEVELS.length) newIndex = LEVELS.length - 1;
      currentLevelIndex = newIndex;
      buildLevel(currentLevelIndex);
      hideCompleteDialog(); updateLevelInfo();
      updateStatus("é—œå¡è¨­å®šå·²æ›´æ–°ã€‚");
    }

    // ========= Blockly Init =========
    function defineBlocks() {
      Blockly.Blocks['mc_move'] = {
        init: function () {
          this.appendDummyInput().appendField("å‰é€²ä¸€æ ¼");
          this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(200);
        }
      };
      Blockly.JavaScript['mc_move'] = function (block) { return 'commands.push("MOVE");\n'; };
      Blockly.Blocks['mc_turn_left'] = {
        init: function () {
          this.appendDummyInput().appendField("å‘å·¦è½‰");
          this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(180);
        }
      };
      Blockly.JavaScript['mc_turn_left'] = function (block) { return 'commands.push("LEFT");\n'; };
      Blockly.Blocks['mc_turn_right'] = {
        init: function () {
          this.appendDummyInput().appendField("å‘å³è½‰");
          this.setPreviousStatement(true, null); this.setNextStatement(true, null); this.setColour(180);
        }
      };
      Blockly.JavaScript['mc_turn_right'] = function (block) { return 'commands.push("RIGHT");\n'; };
    }

    function initBlockly() {
      defineBlocks();
      // ä¿®æ”¹ï¼šä½¿ç”¨ controls_repeat æ›¿ä»£ controls_repeat_ext
      const toolbox = `
        <xml xmlns="https://developers.google.com/blockly/xml">
          <block type="mc_move"></block>
          <block type="mc_turn_left"></block>
          <block type="mc_turn_right"></block>
          <block type="controls_repeat">
            <field name="TIMES">4</field>
          </block>
        </xml>
      `;
      workspace = Blockly.inject('blocklyDiv', {
        toolbox: toolbox,
        horizontalLayout: true,
        toolboxPosition: 'start',
        scrollbars: true,
        trashcan: true,
        zoom: { startScale: 1.0, maxScale: 2.5, minScale: 0.5, scaleSpeed: 1.2 }
      });
      
      const blocklyArea = document.getElementById('blocklyArea');
      const onResize = function(entries) {
        Blockly.svgResize(workspace);
      };
      const resizeObserver = new ResizeObserver(onResize);
      resizeObserver.observe(blocklyArea);

      setTimeout(() => {
        Blockly.svgResize(workspace);
      }, 100);
    }

    // ========= Three.js =========
    function createVoxel(color, x, y, z, sx, sy, sz) {
      const geometry = new THREE.BoxGeometry(sx, sy, sz);
      const material = new THREE.MeshStandardMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);
      mesh.castShadow = true; mesh.receiveShadow = true;
      return mesh;
    }

    function createNoiseTexture(colorHex) {
      const size = 64; 
      const data = new Uint8Array(size * size * 4);
      const baseColor = new THREE.Color(colorHex);
      for (let i = 0; i < size * size; i++) {
        const n = (Math.random() - 0.5) * 0.15;
        const r = Math.min(1, Math.max(0, baseColor.r + n));
        const g = Math.min(1, Math.max(0, baseColor.g + n));
        const b = Math.min(1, Math.max(0, baseColor.b + n));
        data[i * 4] = Math.floor(r * 255);
        data[i * 4 + 1] = Math.floor(g * 255);
        data[i * 4 + 2] = Math.floor(b * 255);
        data[i * 4 + 3] = 255; 
      }
      const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
      texture.needsUpdate = true;
      texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter;
      return texture;
    }

    function createSteve(){const s=new THREE.Group();const k=0xCF9E7A;const r=0x3A2208;const h=new THREE.Group();h.position.y=1.5;h.add(createVoxel(k,0,0,0,.4,.4,.4));h.add(createVoxel(r,0,.21,0,.42,.05,.42));h.add(createVoxel(r,0,.1,-.21,.42,.2,.05));h.add(createVoxel(r,-.21,.1,0,.05,.2,.4));h.add(createVoxel(r,.21,.1,0,.05,.2,.4));const z=.205;h.add(createVoxel(0xFFFFFF,.1,.05,z,.1,.05,.02));h.add(createVoxel(0x2222FF,.12,.05,z+.001,.05,.05,.02));h.add(createVoxel(0xFFFFFF,-.1,.05,z,.1,.05,.02));h.add(createVoxel(0x2222FF,-.12,.05,z+.001,.05,.05,.02));h.add(createVoxel(0xB87E6A,0,-.05,z,.08,.05,.02));h.add(createVoxel(0x9E6A4A,0,-.12,z,.2,.06,.02));s.add(h);s.add(createVoxel(0x009999,0,.9,0,.4,.6,.2));const l={};function m(x,y,c,w,h,d,i){const g=new THREE.Group();g.position.set(x,y,0);g.add(createVoxel(c,0,-h/2+(i?0:.1),0,w,h,d));s.add(g);return g}l.armL=m(-.3,1.1,k,.18,.6,.18,0);l.armR=m(.3,1.1,k,.18,.6,.18,0);l.legL=m(-.1,.6,0x0000AA,.18,.6,.18,1);l.legR=m(.1,.6,0x0000AA,.18,.6,.18,1);return{group:s,limbs:l}}
    function createCreeper(){const g=new THREE.Group();const c=0x3ba635;g.add(createVoxel(c,0,.9,0,.5,1,.4));const h=new THREE.Group();h.position.y=1.6;h.add(createVoxel(c,0,0,0,.5,.5,.5));h.add(createVoxel(0,-.1,.05,.26,.1,.1,.02));h.add(createVoxel(0,.1,.05,.26,.1,.1,.02));h.add(createVoxel(0,0,-.1,.26,.12,.12,.02));g.add(h);[[-.15,.15,-.12],[.15,.15,-.12],[-.15,.15,.12],[.15,.15,.12]].forEach(p=>g.add(createVoxel(c,p[0],p[1],p[2],.18,.3,.18)));return g}
    function createCow(){const g=new THREE.Group(),b=0x8b4513,s=0xffffff,l=0x4b3621;g.add(createVoxel(b,0,.7,0,.9,.5,.5));g.add(createVoxel(s,.15,.8,.26,.2,.2,.05));g.add(createVoxel(s,-.25,.6,-.26,.25,.15,.05));const h=new THREE.Group();h.position.set(0,1,.4);h.add(createVoxel(b,0,0,0,.4,.4,.4));h.add(createVoxel(0x222222,-.22,.2,0,.05,.12,.05));h.add(createVoxel(0x222222,.22,.2,0,.05,.12,.05));g.add(h);[[-.3,.2,-.18],[.3,.2,-.18],[-.3,.2,.18],[.3,.2,.18]].forEach(p=>g.add(createVoxel(l,p[0],p[1],p[2],.18,.4,.18)));return g}
    function createSheep(){const g=new THREE.Group(),w=0xffffff,f=0xd8c0a8,l=0x777777;g.add(createVoxel(w,0,.8,0,.9,.6,.5));g.add(createVoxel(f,0,.85,.45,.4,.4,.4));[[-.3,.175,-.18],[.3,.175,-.18],[-.3,.175,.18],[.3,.175,.18]].forEach(p=>g.add(createVoxel(l,p[0],p[1],p[2],.18,.35,.18)));return g}
    function createEnderman(){const g=new THREE.Group(),b=0x111111,p=0xcc00cc;g.add(createVoxel(b,0,1.4,0,.4,.6,.2));const h=new THREE.Group();h.position.y=1.95;h.add(createVoxel(b,0,0,0,.4,.4,.4));h.add(createVoxel(p,-.12,-.05,.21,.1,.05,.02));h.add(createVoxel(p,.12,-.05,.21,.1,.05,.02));g.add(h);g.add(createVoxel(b,-.28,1.3,0,.08,.9,.08));g.add(createVoxel(b,.28,1.3,0,.08,.9,.08));g.add(createVoxel(b,-.1,.55,0,.1,1.1,.1));g.add(createVoxel(b,.1,.55,0,.1,1.1,.1));return g}
    function createSpider(){const g=new THREE.Group(),d=0x222222,r=0xff0000;const h=new THREE.Group();h.position.set(0,.4,.4);h.add(createVoxel(d,0,0,0,.35,.3,.35));h.add(createVoxel(r,-.1,.05,.18,.08,.05,.02));h.add(createVoxel(r,.1,.05,.18,.08,.05,.02));g.add(h);g.add(createVoxel(d,0,.45,-.2,.5,.35,.6));[[-.4,.3,.2],[.4,.3,.2],[-.45,.3,0],[.45,.3,0],[-.4,.3,-.3],[.4,.3,-.3]].forEach(p=>g.add(createVoxel(d,p[0],p[1],p[2],.3,.08,.08)));return g}
    function createWolf(){const g=new THREE.Group(),f=0xdddddd,n=0x333333;g.add(createVoxel(f,0,.5,0,.4,.4,.7));const h=new THREE.Group();h.position.set(0,.8,.35);h.add(createVoxel(f,0,0,0,.35,.35,.35));h.add(createVoxel(n,0,-.05,.2,.15,.15,.1));h.add(createVoxel(f,-.1,.2,.05,.08,.1,.05));h.add(createVoxel(f,.1,.2,.05,.08,.1,.05));g.add(h);[[-.12,.15,-.25],[.12,.15,-.25],[-.12,.15,.25],[.12,.15,.25]].forEach(p=>g.add(createVoxel(f,p[0],p[1],p[2],.12,.3,.12)));g.add(createVoxel(f,0,.5,-.4,.1,.1,.3));return g}
    function createSnowGolem(){const g=new THREE.Group(),s=0xffffff,p=0xd35400;g.add(createVoxel(s,0,.4,0,.6,.6,.6));g.add(createVoxel(s,0,.9,0,.45,.45,.45));const h=new THREE.Group();h.position.y=1.35;h.add(createVoxel(p,0,0,0,.4,.45,.4));g.add(h);g.add(createVoxel(0x5d4037,-.35,1,0,.3,.05,.05));g.add(createVoxel(0x5d4037,.35,1,0,.3,.05,.05));return g}

    // ========= Clouds =========
    function initClouds() {
      const cloudsGroup = new THREE.Group();
      const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
      for (let i = 0; i < 15; i++) {
        const cloud = new THREE.Group();
        const chunks = 3 + Math.floor(Math.random() * 4);
        for (let j = 0; j < chunks; j++) {
          const sx = 1.5 + Math.random() * 1.5; const sy = 0.5 + Math.random() * 0.5; const sz = 1.0 + Math.random() * 1.0;
          const ox = (Math.random() - 0.5) * 2.5; const oy = (Math.random() - 0.5) * 0.5; const oz = (Math.random() - 0.5) * 1.5;
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz), cloudMat);
          mesh.position.set(ox, oy, oz); cloud.add(mesh);
        }
        const x = (Math.random() - 0.5) * 60; const z = -20 - Math.random() * 30; const y = 3 + Math.random() * 8;
        cloud.position.set(x, y, z); cloudsGroup.add(cloud);
      }
      scene.add(cloudsGroup);
    }

    // ========= Logic (Diagnosis) =========
    function computePathSegment(start, target) {
      let blockHtmls = [];
      let cx = start.x; let cz = start.z; let cdir = start.dir;
      let dx = target.x - cx; let dz = target.z - cz;

      function turnTo(targetDir) {
        let diff = targetDir - cdir;
        if (diff === 3) diff = -1; if (diff === -3) diff = 1;
        if (diff === 0) return;
        if (Math.abs(diff) === 2) { blockHtmls.push(createBlockHtml('RIGHT')); blockHtmls.push(createBlockHtml('RIGHT')); }
        else if (diff === 1) { blockHtmls.push(createBlockHtml('RIGHT')); }
        else if (diff === -1) { blockHtmls.push(createBlockHtml('LEFT')); }
        cdir = targetDir;
      }

      const moveX = () => {
        if (dx !== 0) {
          const wantDir = dx > 0 ? 1 : 3;
          turnTo(wantDir);
          const steps = Math.abs(dx);
          for(let k=0; k<steps; k++) { blockHtmls.push(createBlockHtml('MOVE')); }
          cx += dx; 
        }
      };
      const moveZ = () => {
        if (dz !== 0) {
          const wantDir = dz > 0 ? 2 : 0;
          turnTo(wantDir);
          const steps = Math.abs(dz);
          for(let k=0; k<steps; k++) { blockHtmls.push(createBlockHtml('MOVE')); }
          cz += dz;
        }
      };

      if ((cdir === 1 || cdir === 3) && dx !== 0) { moveX(); moveZ(); }
      else { moveZ(); moveX(); }

      const htmlStr = blockHtmls.join("").replace(/<div class="flex justify-center -my-1 last:hidden opacity-50">/g, '<div class="flex justify-center -my-1 opacity-50">');
      return { html: htmlStr, endState: { x: cx, z: cz, dir: cdir } };
    }

    function getHintForNextTarget(level, collectedCount) {
      let vPlayer = { ...level.start }; 
      let pathHtml = "";
      let targetLabel = "";
      const targetIndex = collectedCount;
      if (targetIndex >= level.targetZhuyin.length) return { html: "å·²å®Œæˆæ‰€æœ‰æ”¶é›†ï¼", label: "å®Œæˆ" };

      for (let i = 0; i < targetIndex; i++) {
        const pastSym = level.targetZhuyin[i];
        const pastItem = items.find(it => it.symbol === pastSym);
        if (pastItem) {
          const res = computePathSegment(vPlayer, { x: pastItem.gridX, z: pastItem.gridZ });
          vPlayer = res.endState;
        }
      }

      const currentTargetSym = level.targetZhuyin[targetIndex];
      const currentTargetItem = items.find(it => it.symbol === currentTargetSym);
      
      if (currentTargetItem) {
        const res = computePathSegment(vPlayer, { x: currentTargetItem.gridX, z: currentTargetItem.gridZ });
        pathHtml = res.html;
        let startLabel = (targetIndex === 0) ? "èµ·é»" : `ã€Œ${level.targetZhuyin[targetIndex-1]}ã€`;
        targetLabel = `å¾ ${startLabel} å‰å¾€ã€Œ${currentTargetSym}ã€`;
      }
      return { html: pathHtml, label: targetLabel };
    }

    // ========= Movement & Animation Functions =========
    function updatePlayerTransform() {
      if (!player) return;
      const worldX = playerState.x - GRID_OFFSET;
      const worldZ = playerState.z - GRID_OFFSET;
      player.position.set(worldX, 0, worldZ);
      player.rotation.y = DIR_ROTATIONS[playerState.dir];
    }

    function setIdlePose() {
      if (!playerLimbs.armL) return;
      playerLimbs.armL.rotation.x = 0;
      playerLimbs.armR.rotation.x = 0;
      playerLimbs.legL.rotation.x = 0;
      playerLimbs.legR.rotation.x = 0;
    }

    function updateWalkAnimation(progress) {
      if (!playerLimbs.armL) return;
      const swing = Math.sin(progress * Math.PI) * 0.7;
      playerLimbs.armL.rotation.x =  swing;
      playerLimbs.armR.rotation.x = -swing;
      playerLimbs.legL.rotation.x = -swing;
      playerLimbs.legR.rotation.x =  swing;
    }

    function resetPlayer() {
      const level = LEVELS[currentLevelIndex];
      playerState.x = level.start.x;
      playerState.z = level.start.z;
      playerState.dir = level.start.dir;

      collectedSymbols = [];
      items.forEach(item => {
        item.collected = false;
        item.mesh.visible = true;
      });

      updatePlayerTransform();
      setIdlePose();
      hideCompleteDialog();
      updateCollectedInfo();
    }

    // ========= Runtime Control =========
    function createZhuyinCard(char) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, 256, 256);

      ctx.font = 'bold 210px "Microsoft JhengHei", "Noto Sans TC", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // å¤–åœˆæ·¡è—å…‰æšˆï¼ŒæŸ”åŒ–é‚Šç·£
      ctx.lineWidth = 18;
      ctx.strokeStyle = 'rgba(0,255,255,0.7)';
      ctx.strokeText(char, 128, 140);

      // ä¸»å­—
      ctx.lineWidth = 10;
      ctx.strokeStyle = '#FFFFFF';
      ctx.strokeText(char, 128, 140);
      ctx.fillStyle = '#00FFFF';
      ctx.fillText(char, 128, 140);

      const texture = new THREE.CanvasTexture(canvas);
      if (renderer) {
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      }
      texture.needsUpdate = true;

      // æ”¹ç”¨ã€Œå¹³é¢ã€ï¼Œå°±ä¸æœƒæœ‰åšåº¦é‚Šç·š
      const geometry = new THREE.PlaneGeometry(1.3, 1.3);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
      });

      const mesh = new THREE.Mesh(geometry, material);
      return mesh;
    }

    function checkPickup(currentStep) {
      const level = LEVELS[currentLevelIndex];
      if (!level) return true;
      for (const item of items) {
        if (!item.collected && item.gridX === playerState.x && item.gridZ === playerState.z) {
          const expected = level.targetZhuyin[collectedSymbols.length];
          if (item.symbol === expected) {
            item.collected = true; item.mesh.visible = false;
            collectedSymbols.push(item.symbol);
            updateCollectedInfo(); updateStatus("æ”¶é›†åˆ°ï¼šã€Œ" + item.symbol + "ã€");
            if (collectedSymbols.length === level.targetZhuyin.length) {
              setTimeout(() => showCompleteDialog(level), 500);
            }
            return true;
          } else {
            const hintData = getHintForNextTarget(level, collectedSymbols.length);
            const errorMsg = `
              <div class="space-y-3">
                <div class="text-rose-600 font-bold">âš ï¸ é †åºéŒ¯èª¤ (ç¬¬ ${currentStep} æ­¥)</div>
                <div class="text-slate-700">æ‹¿åˆ°ã€Œ${item.symbol}ã€ï¼Œä½†æ‡‰å…ˆæ‹¿ã€Œ${expected}ã€ã€‚</div>
                <div class="bg-emerald-50 p-3 rounded border border-emerald-100 mt-2">
                  <div class="text-emerald-800 font-semibold mb-2">ğŸ’¡ åƒè€ƒè§£ç­” (${hintData.label})ï¼š</div>
                  <div class="flex flex-col items-center space-y-0 max-h-60 overflow-y-auto custom-scrollbar">
                    ${hintData.html}
                  </div>
                </div>
              </div>`;
            showMsg(errorMsg, "ç¨‹å¼è¨ºæ–·å ±å‘Š");
            return false;
          }
        }
      }
      return true;
    }

    async function animateMove(currentStep) {
      const v = [{dx:0,dz:-1},{dx:1,dz:0},{dx:0,dz:1},{dx:-1,dz:0}][playerState.dir];
      const nx = playerState.x + v.dx; const nz = playerState.z + v.dz;

      if (nx < 0 || nx >= GRID_SIZE || nz < 0 || nz >= GRID_SIZE) {
        updateStatus("æ’åˆ°ç‰†å£äº†ï¼");
        const hintData = getHintForNextTarget(LEVELS[currentLevelIndex], collectedSymbols.length);
        const errorMsg = `
          <div class="space-y-3">
            <div class="text-rose-600 font-bold">âš ï¸ ç™¼ç”Ÿæ’ç‰† (ç¬¬ ${currentStep} æ­¥)</div>
            <div class="text-slate-700">è·‘å‡ºåœ°åœ–äº†ï¼è«‹æª¢æŸ¥æ­¥æ•¸ã€‚</div>
            <div class="bg-emerald-50 p-3 rounded border border-emerald-100 mt-2">
              <div class="text-emerald-800 font-semibold mb-2">ğŸ’¡ åƒè€ƒè§£ç­” (${hintData.label})ï¼š</div>
              <div class="flex flex-col items-center space-y-0 max-h-60 overflow-y-auto custom-scrollbar">
                ${hintData.html}
              </div>
            </div>
          </div>`;
        showMsg(errorMsg, "ç¨‹å¼è¨ºæ–·å ±å‘Š");
        return false;
      }
      
      const startX = player.position.x; const startZ = player.position.z;
      const endX = startX + v.dx; const endZ = startZ + v.dz;
      for (let i = 0; i <= 14; i++) {
        const t = i / 14;
        player.position.x = startX + (endX - startX) * t;
        player.position.z = startZ + (endZ - startZ) * t;
        updateWalkAnimation(t); await delay(20);
      }
      playerState.x = nx; playerState.z = nz;
      updatePlayerTransform(); setIdlePose();
      return checkPickup(currentStep);
    }

    async function animateTurn(deltaDir) {
      const oldDir = playerState.dir;
      const newDir = (playerState.dir + deltaDir + 4) % 4;
      const startRot = DIR_ROTATIONS[oldDir];
      const endRot   = DIR_ROTATIONS[newDir];
      for (let i = 0; i <= 12; i++) {
        const t = i / 12;
        player.rotation.y = startRot + (endRot - startRot) * t;
        await delay(16);
      }
      playerState.dir = newDir;
      updatePlayerTransform(); setIdlePose();
      return true;
    }

    async function executeCommands(commands) {
      updateStatus("åŸ·è¡Œä¸­...");
      for (let i = 0; i < commands.length; i++) {
        const cmd = commands[i]; let success = true;
        if (cmd === "MOVE") success = await animateMove(i + 1);
        else if (cmd === "LEFT") success = await animateTurn(-1);
        else if (cmd === "RIGHT") success = await animateTurn(1);
        if (!success) return false;
      }
      const level = LEVELS[currentLevelIndex];
      if (collectedSymbols.length < level.targetZhuyin.length) {
         const hintData = getHintForNextTarget(level, collectedSymbols.length);
         const errorMsg = `
           <div class="space-y-3">
             <div class="text-orange-600 font-bold">âš ï¸ åŸ·è¡Œå®Œç•¢ï¼Œå°šæœªéé—œ</div>
             <div class="text-slate-700">é‚„æœ‰æ³¨éŸ³æ²’æ‹¿åˆ°å–”ï¼</div>
             <div class="bg-orange-50 p-3 rounded border border-orange-100 mt-2">
               <div class="text-orange-800 font-semibold mb-2">ğŸ’¡ åƒè€ƒè§£ç­” (${hintData.label})ï¼š</div>
               <div class="flex flex-col items-center space-y-0 max-h-60 overflow-y-auto custom-scrollbar">
                 ${hintData.html}
               </div>
             </div>
           </div>`;
         showMsg(errorMsg, "ç¨‹å¼è¨ºæ–·å ±å‘Š");
      } else {
         updateStatus("æˆåŠŸï¼");
      }
      return true;
    }

    async function runCode() {
      if (!workspace) return;
      let code = "";
      const commands = [];
      try {
        code = Blockly.JavaScript.workspaceToCode(workspace);
        const wrapped = new Function("commands", code);
        wrapped(commands);
      } catch (e) {
        console.error(e); showMsg("ç¨‹å¼ç¢¼éŒ¯èª¤ï¼š" + e); return;
      }
      if (!commands.length) { updateStatus("ç›®å‰æ²’æœ‰æŒ‡ä»¤å–”"); return; }
      await executeCommands(commands);
    }

    function buildLevel(levelIndex) {
      const level = LEVELS[levelIndex];
      if (!level || !scene) return;

      if (levelGroup) {
        scene.remove(levelGroup);
      }
      levelGroup = new THREE.Group();
      scene.add(levelGroup);

      tiles = [];
      items = [];
      extraPlayers = [];
      player = null;
      playerLimbs = {};

      const tileSize    = 0.9;
      const dirtHeight  = 0.6;
      const grassHeight = 0.2;

      // é å…ˆå»ºç«‹è‰åœ°è²¼åœ–
      const normalGrassTex = createNoiseTexture(0x337733);
      const darkGrassTex   = createNoiseTexture(0x225522);

      for (let z = 0; z < GRID_SIZE; z++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = level.map[z][x];
          const hasItem = level.itemMapping && level.itemMapping[cell];
          const worldX = x - GRID_OFFSET;
          const worldZ = z - GRID_OFFSET;

          const dirtGeo  = new THREE.BoxGeometry(tileSize, dirtHeight, tileSize);
          const grassGeo = new THREE.BoxGeometry(tileSize * 0.98, grassHeight, tileSize * 0.98);

          const dirtMat  = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
          
          // ä¿®æ”¹è™•ï¼šä½¿ç”¨ç”¢ç”Ÿå‡ºä¾†çš„åƒç´ é›œè¨Šè²¼åœ–
          const grassMat = new THREE.MeshStandardMaterial({ 
            map: hasItem ? darkGrassTex : normalGrassTex
          });

          const dirt = new THREE.Mesh(dirtGeo, dirtMat);
          dirt.position.set(worldX, -grassHeight - dirtHeight / 2, worldZ);
          dirt.receiveShadow = true;
          levelGroup.add(dirt);

          const grass = new THREE.Mesh(grassGeo, grassMat);
          grass.position.set(worldX, -grassHeight / 2, worldZ);
          grass.receiveShadow = true;
          grass.castShadow = false;
          levelGroup.add(grass);
          tiles.push(grass);

          if (hasItem) {
            const shadowGeo = new THREE.PlaneGeometry(1.05, 1.05);
            const shadowMat = new THREE.MeshStandardMaterial({
              color: 0x000000,
              transparent: true,
              opacity: 0.35,
              side: THREE.DoubleSide
            });
            const shadow = new THREE.Mesh(shadowGeo, shadowMat);
            shadow.rotation.x = -Math.PI / 2;
            shadow.position.set(worldX, 0.01, worldZ);
            shadow.receiveShadow = true;
            levelGroup.add(shadow);

            const char = level.itemMapping[cell];
            const mesh = createZhuyinCard(char);
            const baseY = 1.2;
            mesh.position.set(worldX, baseY, worldZ);
            mesh.rotation.x = -Math.PI / 3.5;
            levelGroup.add(mesh);

            items.push({
              mesh,
              symbol: char,
              gridX: x,
              gridZ: z,
              collected: false,
              baseY: baseY,
              floatPhase: Math.random() * Math.PI * 2
            });
          }
        }
      }

      const steve = createSteve();
      player = steve.group;
      playerLimbs = steve.limbs;
      levelGroup.add(player);

      // é¡å¤– 1-2 å€‹éš¨æ©Ÿ NPC
      const bannedForExtra = new Set();
      bannedForExtra.add(level.start.x + "," + level.start.z);
      for (const item of items) {
        bannedForExtra.add(item.gridX + "," + item.gridZ);
      }
      const extraCount = 1 + Math.floor(Math.random() * 2); // 1 æˆ– 2 å€‹
      const extraPositions = getRandomGridPositions(extraCount, bannedForExtra);
      
      const npcCreators = [
        createCreeper,     // è‹¦åŠ›æ€•
        createCow,         // ä¹³ç‰›
        createSheep,       // ç¾Š
        createEnderman,    // çµ‚ç•Œä½¿è€… (æ–°)
        createSpider,      // èœ˜è›› (æ–°)
        createWolf,        // ç‹¼ (æ–°)
        createSnowGolem    // é›ªäºº (æ–°)
      ];

      extraPositions.forEach(pos => {
        // éš¨æ©Ÿé¸ä¸€å€‹ç¨®é¡
        const typeIdx = Math.floor(Math.random() * npcCreators.length);
        const g = npcCreators[typeIdx]();

        const worldX = pos.x - GRID_OFFSET;
        const worldZ = pos.z - GRID_OFFSET;
        g.position.set(worldX, 0, worldZ);
        g.rotation.y = DIR_ROTATIONS[Math.floor(Math.random() * DIR_ROTATIONS.length)];
        levelGroup.add(g);
        extraPlayers.push(g);
      });

      resetPlayer();
      updateLevelInfo();
    }

    function resizeRenderer() {
      if (!renderer || !camera) return;
      const canvas = renderer.domElement;
      const width = canvas.clientWidth || canvas.offsetWidth;
      const height = canvas.clientHeight || canvas.offsetHeight;
      if (!width || !height) return;
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    function animate(time) {
      requestAnimationFrame(animate);
      if (!renderer || !scene || !camera) return;

      const t = (time || 0) * 0.001;
      const floatAmp = 0.1;
      const floatSpeed = 1.5;

      for (const item of items) {
        if (!item.mesh || item.collected) continue;
        item.mesh.position.y =
          item.baseY + Math.sin(t * floatSpeed + item.floatPhase) * floatAmp;
      }

      renderer.render(scene, camera);
    }

    function initThree() {
      const canvas = document.getElementById('gameCanvas');
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.shadowMap.enabled = true;
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      const width = canvas.clientWidth || 800; const height = canvas.clientHeight || 600;
      camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
      camera.position.set(0, 6, 12); camera.lookAt(0, 0, 0);
      renderer.setSize(width, height, false);
      const hemiLight = new THREE.HemisphereLight(0xffeeb1, 0x080820, 0.8);
      hemiLight.position.set(0, 20, 0); scene.add(hemiLight);
      const dirLight = new THREE.DirectionalLight(0xffaa33, 0.8);
      dirLight.position.set(5, 10, 7); dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
      scene.add(dirLight);
      buildLevel(currentLevelIndex);
      initClouds();
      animate();
      window.addEventListener('resize', resizeRenderer);
    }

    window.addEventListener('load', function () {
      initBlockly();
      initThree();
      updateLevelInfo();

      document.getElementById('runBtn').addEventListener('click', runCode);
      document.getElementById('resetBtn').addEventListener('click', () => { resetPlayer(); updateStatus("é‡è¨­å®Œæˆ"); });

      const prevBtn = document.getElementById('prevLevelBtn');
      const nextBtn = document.getElementById('nextLevelBtn');
      if (prevBtn) prevBtn.addEventListener('click', () => { if (currentLevelIndex > 0) setLevel(currentLevelIndex - 1); });
      if (nextBtn) nextBtn.addEventListener('click', () => { if (currentLevelIndex < LEVELS.length - 1) setLevel(currentLevelIndex + 1); });

      const restartBtn = document.getElementById('dialogRestartBtn');
      const dialogNextBtn = document.getElementById('dialogNextBtn');
      if (restartBtn) restartBtn.addEventListener('click', () => { resetPlayer(); hideCompleteDialog(); });
      if (dialogNextBtn) dialogNextBtn.addEventListener('click', () => { if (currentLevelIndex < LEVELS.length - 1) setLevel(currentLevelIndex + 1); else hideCompleteDialog(); });

      const completeDialog = document.getElementById('completeDialog');
      if (completeDialog) completeDialog.addEventListener('click', (e) => { if (e.target.id === 'completeDialog') hideCompleteDialog(); });

      const cfgApplyBtn = document.getElementById('cfgApplyCurrent');
      const cfgAddBtn   = document.getElementById('cfgAddLevel');
      const wordInput   = document.getElementById('cfgWordInput');
      const zhuyinInput = document.getElementById('cfgZhuyinInput');

      if (cfgApplyBtn) {
        cfgApplyBtn.addEventListener('click', function () {
          const w = (wordInput.value || "").trim(); const z = (zhuyinInput.value || "").trim();
          if (!w || !z) { showMsg("è«‹è¼¸å…¥åœ‹å­—å’Œæ³¨éŸ³"); return; }
          levelInputConfig[currentLevelIndex] = { word: w, zhuyin: z };
          rebuildLevelsAndStay(currentLevelIndex);
        });
      }
      if (cfgAddBtn) {
        cfgAddBtn.addEventListener('click', function () {
          const w = (wordInput.value || "").trim(); const z = (zhuyinInput.value || "").trim();
          if (!w || !z) { showMsg("è«‹è¼¸å…¥åœ‹å­—å’Œæ³¨éŸ³"); return; }
          levelInputConfig.push({ word: w, zhuyin: z });
          rebuildLevelsAndStay(levelInputConfig.length - 1);
        });
      }

      const toggleInfoBtn = document.getElementById('toggleInfoBtn');
      const infoBody = document.getElementById('infoBody');
      const toggleIcon = document.getElementById('toggleIcon');
      let isInfoExpanded = true;
      if (toggleInfoBtn && infoBody && toggleIcon) {
        toggleInfoBtn.addEventListener('click', function() {
          isInfoExpanded = !isInfoExpanded;
          if (isInfoExpanded) {
            infoBody.style.height = infoBody.scrollHeight + "px";
            toggleIcon.style.transform = "rotate(0deg)";
          } else {
            infoBody.style.height = "0px";
            toggleIcon.style.transform = "rotate(180deg)";
          }
        });
        infoBody.style.height = "auto";
      }
    });
  </script>
</body>
</html>
