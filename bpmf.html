<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ³¨éŸ³ç¬¦è™Ÿå¤§å†’éšª</title>
    
    <!-- å¼•å…¥ React æ ¸å¿ƒ -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- å¼•å…¥ Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- å¼•å…¥ Blockly -->
    <script src="https://unpkg.com/blockly@9.3.3/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly@9.3.3/blocks_compressed.js"></script>
    <script src="https://unpkg.com/blockly@9.3.3/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly@9.3.3/msg/zh-hant.js"></script>

    <!-- å­—å‹è¨­å®š (ç§»é™¤å°è‡´éŒ¯èª¤çš„ CSS) -->
    <style>
        body { font-family: "Microsoft JhengHei", "Noto Sans TC", sans-serif; }
        .blocklyToolboxDiv { background-color: #f3f4f6 !important; }
        .blocklyFlyoutBackground { fill: #e5e7eb !important; }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden h-screen w-screen">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- SVG Icons ---
        const IconPlay = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>;
        const IconRotate = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>;
        const IconCheck = () => <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#4ade80" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>;
        const IconAlert = () => <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#f87171" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>;
        const IconCode = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>;

        // --- é—œå¡è³‡æ–™ ---
        const LEVELS_DATA = [
            {
                targetChar: "é †",
                targetZhuyin: ["ã„•", "ã„¨", "ã„£", "Ë‹"],
                // 9x9 Map
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 10, 1, 1, 1, 1], // ã„•
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 11, 1, 1, 1, 1, 1, 12, 1], // ã„¨, ã„£
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 13, 1, 1, 1, 1], // Ë‹
                    [1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                itemMapping: { 10: "ã„•", 11: "ã„¨", 12: "ã„£", 13: "Ë‹" },
                start: { x: 4, z: 4, dir: 0 }, 
            },
            {
                targetChar: "å­¸",
                targetZhuyin: ["ã„’", "ã„©", "ã„", "ËŠ"],
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 13, 1, 1, 1, 1, 1, 12, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 10, 1, 1, 1, 1, 1, 11, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                itemMapping: { 10: "ã„’", 11: "ã„©", 12: "ã„", 13: "ËŠ" },
                start: { x: 4, z: 4, dir: 2 }, 
            }
        ];

        const ZhuyinGame = () => {
            const [isLibrariesLoaded, setIsLibrariesLoaded] = useState(false);
            const [gameState, setGameState] = useState('IDLE');
            const [failReason, setFailReason] = useState('');
            const [currentLevel, setCurrentLevel] = useState(0);
            const [collectedSymbols, setCollectedSymbols] = useState([]); 
            
            const blocklyDiv = useRef(null);
            const workspaceRef = useRef(null);
            const canvasRef = useRef(null);
            const mountRef = useRef(null);
            
            const sceneRef = useRef(null);
            const playerRef = useRef(null); 
            const playerLimbsRef = useRef({ armL: null, armR: null, legL: null, legR: null });
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const itemsRef = useRef([]); 
            const shadowsRef = useRef([]); // ç®¡ç†é™°å½±
            
            const playerState = useRef({ x: 0, z: 0, dir: 0 }); 
            const levelData = useRef(null);

            // --- è¨»å†Š Blockly ---
            const registerBlocklyDefinitions = () => {
                if (!window.Blockly || !window.Blockly.JavaScript) return;

                const blocks = ['mc_move', 'mc_turn_left', 'mc_turn_right'];
                const titles = { 'mc_move': 'å‰é€²ä¸€æ ¼', 'mc_turn_left': 'å·¦è½‰ â†º', 'mc_turn_right': 'å³è½‰ â†»' };

                blocks.forEach(blockName => {
                    if (!window.Blockly.Blocks[blockName]) {
                        window.Blockly.Blocks[blockName] = {
                            init: function() {
                                this.appendDummyInput().appendField(titles[blockName]);
                                this.setPreviousStatement(true, null);
                                this.setNextStatement(true, null);
                                this.setColour(160);
                            }
                        };
                    }
                });

                const genCode = {
                    'mc_move': 'commands.push("MOVE");\n',
                    'mc_turn_left': 'commands.push("LEFT");\n',
                    'mc_turn_right': 'commands.push("RIGHT");\n'
                };

                Object.keys(genCode).forEach(key => {
                    const func = () => genCode[key];
                    window.Blockly.JavaScript[key] = func;
                    if (window.Blockly.JavaScript.forBlock) {
                        window.Blockly.JavaScript.forBlock[key] = func;
                    }
                });
            };

            // --- åˆå§‹åŒ–ç¢ºèª ---
            useEffect(() => {
                const checkLoaded = setInterval(() => {
                    if (window.THREE && window.Blockly && window.Blockly.JavaScript) {
                        clearInterval(checkLoaded);
                        setIsLibrariesLoaded(true);
                    }
                }, 100);
                return () => clearInterval(checkLoaded);
            }, []);

            // --- Three.js åˆå§‹åŒ– ---
            const initScene = useCallback(() => {
                if (!canvasRef.current || !window.THREE) return;
                const THREE = window.THREE;

                const width = canvasRef.current.clientWidth;
                const height = canvasRef.current.clientHeight;
                
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); 
                scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

                // å„ªåŒ–å¾Œçš„æ”å½±æ©Ÿè¦–è§’
                const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 100);
                camera.position.set(0, 18, 12); 
                camera.lookAt(0, 0, 0);
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ canvas: canvasRef.current, antialias: true, alpha: false });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                rendererRef.current = renderer;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(20, 30, 20);
                dirLight.castShadow = true;
                scene.add(dirLight);

                sceneRef.current = scene;

                const animate = () => {
                    if (!mountRef.current) return;
                    requestAnimationFrame(animate);
                    
                    itemsRef.current.forEach((item, idx) => {
                        if (item.mesh.visible) {
                            // ç¬¦è™Ÿä¸Šä¸‹æµ®å‹•
                            item.mesh.position.y = 1.3 + Math.sin(Date.now() * 0.003 + idx) * 0.1;
                        }
                    });

                    renderer.render(scene, camera);
                };
                mountRef.current = true;
                animate();

            }, []);

            // --- è¼”åŠ©å‡½å¼ ---
            const createMultiVoxel = (top, side, bottom, x, y, z) => {
                const THREE = window.THREE;
                const geo = new THREE.BoxGeometry(1, 1, 1);
                const mats = [
                    new THREE.MeshStandardMaterial({ color: side }), 
                    new THREE.MeshStandardMaterial({ color: side }), 
                    new THREE.MeshStandardMaterial({ color: top }),  
                    new THREE.MeshStandardMaterial({ color: bottom }), 
                    new THREE.MeshStandardMaterial({ color: side }), 
                    new THREE.MeshStandardMaterial({ color: side }) 
                ];
                const mesh = new THREE.Mesh(geo, mats);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                const edges = new THREE.EdgesGeometry(geo);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true }));
                mesh.add(line);
                return mesh;
            };

            // å–®é¢å¤§æ³¨éŸ³
            const createZhuyin3D = (char) => {
                const THREE = window.THREE;
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, 128, 128);
                ctx.font = 'bold 110px "Microsoft JhengHei", sans-serif';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 10; 
                ctx.strokeText(char, 64, 64);
                ctx.fillStyle = '#00FFFF'; 
                ctx.fillText(char, 64, 64);
                
                const texture = new THREE.CanvasTexture(canvas);
                const geometry = new THREE.BoxGeometry(1.3, 1.3, 0.05);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, transparent: true, side: THREE.FrontSide, depthWrite: false 
                });
                return new THREE.Mesh(geometry, material);
            };

            // **åœ°é¢é™°å½±æ•ˆæœ (Shadow Plane)**
            const createShadowPlane = () => {
                const THREE = window.THREE;
                const geometry = new THREE.PlaneGeometry(0.8, 0.8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x000000, 
                    transparent: true, 
                    opacity: 0.4,
                    side: THREE.FrontSide
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2; // Lie flat
                return mesh;
            };

            const createVoxel = (color, x, y, z, sx, sy, sz) => {
                const THREE = window.THREE;
                const mesh = new THREE.Mesh(
                    new THREE.BoxGeometry(sx, sy, sz),
                    new THREE.MeshStandardMaterial({ color })
                );
                mesh.position.set(x, y, z);
                mesh.castShadow = true; mesh.receiveShadow = true;
                return mesh;
            };

            // --- å»ºç«‹é—œå¡ ---
            const buildLevel = useCallback((levelIndex) => {
                if (!sceneRef.current || !window.THREE) return;
                const THREE = window.THREE;
                const scene = sceneRef.current;

                for(let i = scene.children.length - 1; i >= 0; i--) { 
                    if(scene.children[i].type !== "DirectionalLight" && scene.children[i].type !== "AmbientLight") {
                        scene.remove(scene.children[i]); 
                    }
                }

                const data = LEVELS_DATA[levelIndex];
                levelData.current = JSON.parse(JSON.stringify(data)); 
                playerState.current = { ...data.start };
                setCollectedSymbols([]);
                setFailReason('');
                itemsRef.current = [];
                shadowsRef.current = [];

                const mapGroup = new THREE.Group();
                const offsetX = -(data.map[0].length * 1) / 2;
                const offsetZ = -(data.map.length * 1) / 2;

                data.map.forEach((row, z) => {
                    row.forEach((cell, x) => {
                        const posX = (x * 1) + offsetX;
                        const posZ = (z * 1) + offsetZ;
                        
                        if (cell > 0) {
                            const grass = createMultiVoxel(0x4C9131, 0x724C30, 0x724C30, posX, -0.5, posZ);
                            mapGroup.add(grass);
                        }

                        if (data.itemMapping && data.itemMapping[cell]) {
                            const char = data.itemMapping[cell];
                            const mesh = createZhuyin3D(char);
                            mesh.position.set(posX, 1.3, posZ); 
                            mesh.rotation.x = -Math.PI / 3.5; 
                            scene.add(mesh);
                            
                            // **åŠ å…¥åœ°é¢é™°å½±**
                            const shadow = createShadowPlane();
                            shadow.position.set(posX, 0.02, posZ);
                            scene.add(shadow);
                            shadowsRef.current.push(shadow);

                            itemsRef.current.push({ mesh, shadow, symbol: char, gridX: x, gridZ: z, collected: false });
                        }
                    });
                });
                scene.add(mapGroup);

                // --- å²å¸å¤« ---
                const steveGroup = new THREE.Group();
                const skin = 0xCF9E7A, hair = 0x3A2208;
                const head = new THREE.Group();
                head.position.y = 1.5;
                head.add(createVoxel(skin, 0, 0, 0, 0.4, 0.4, 0.4));
                head.add(createVoxel(hair, 0, 0.21, 0, 0.42, 0.05, 0.42));
                head.add(createVoxel(hair, 0, 0.1, -0.21, 0.42, 0.2, 0.05));
                head.add(createVoxel(hair, -0.21, 0.1, 0, 0.05, 0.2, 0.4));
                head.add(createVoxel(hair, 0.21, 0.1, 0, 0.05, 0.2, 0.4));
                const fz = 0.205;
                head.add(createVoxel(0xFFFFFF, 0.1, 0.05, fz, 0.1, 0.05, 0.02)); 
                head.add(createVoxel(0x2222FF, 0.12, 0.05, fz+0.001, 0.05, 0.05, 0.02)); 
                head.add(createVoxel(0xFFFFFF, -0.1, 0.05, fz, 0.1, 0.05, 0.02)); 
                head.add(createVoxel(0x2222FF, -0.12, 0.05, fz+0.001, 0.05, 0.05, 0.02)); 
                head.add(createVoxel(0xB87E6A, 0, -0.05, fz, 0.08, 0.05, 0.02)); 
                head.add(createVoxel(0x9E6A4A, 0, -0.12, fz, 0.2, 0.06, 0.02)); 
                steveGroup.add(head);
                steveGroup.add(createVoxel(0x009999, 0, 0.9, 0, 0.4, 0.6, 0.2)); 
                const mkLimb = (x, y, c, w, h, d, isLeg) => {
                    const g = new THREE.Group();
                    g.position.set(x, y, 0);
                    g.add(createVoxel(c, 0, -h/2 + (isLeg?0:0.1), 0, w, h, d));
                    steveGroup.add(g);
                    return g;
                };
                playerLimbsRef.current.armL = mkLimb(-0.3, 1.1, skin, 0.18, 0.6, 0.18, false);
                playerLimbsRef.current.armR = mkLimb(0.3, 1.1, skin, 0.18, 0.6, 0.18, false);
                playerLimbsRef.current.legL = mkLimb(-0.1, 0.6, 0x0000AA, 0.18, 0.6, 0.18, true);
                playerLimbsRef.current.legR = mkLimb(0.1, 0.6, 0x0000AA, 0.18, 0.6, 0.18, true);
                scene.add(steveGroup);
                playerRef.current = steveGroup;

                updatePlayerTransform(data.start.x, data.start.z, data.start.dir, offsetX, offsetZ);

            }, []);

            const updatePlayerTransform = (gridX, gridZ, dirIndex, offX, offZ) => {
                if (!playerRef.current) return;
                playerRef.current.position.set((gridX * 1) + offX, 0, (gridZ * 1) + offZ);
                const rots = [Math.PI, Math.PI/2, 0, -Math.PI/2];
                playerRef.current.rotation.y = rots[dirIndex];
                
                Object.values(playerLimbsRef.current).forEach(l => { if(l) l.rotation.x = 0; });
            };

            // --- Blockly åˆå§‹åŒ– ---
            useEffect(() => {
                if (!isLibrariesLoaded || !blocklyDiv.current) return;
                
                initScene();
                // ç§»é™¤æ­¤è™•çš„ buildLevel(0)ï¼Œäº¤ç”±ä¸‹ä¸€å€‹ useEffect è™•ç†
                registerBlocklyDefinitions();

                const Blockly = window.Blockly;
                if (workspaceRef.current) workspaceRef.current.dispose();

                workspaceRef.current = Blockly.inject(blocklyDiv.current, {
                    toolbox: `
                    <xml>
                        <block type="mc_move"></block>
                        <block type="mc_turn_left"></block>
                        <block type="mc_turn_right"></block>
                        <block type="controls_repeat_ext">
                            <value name="TIMES"><shadow type="math_number"><field name="NUM">4</field></shadow></value>
                        </block>
                    </xml>`,
                    scrollbars: true, trashcan: true,
                    zoom: { startScale: 1.0, maxScale: 3, minScale: 0.8, scaleSpeed: 1.2 },
                    theme: { 'componentStyles': { 'workspaceBackgroundColour': '#f0f0f0', 'toolboxBackgroundColour': '#e5e7eb' } }
                });

                const observer = new ResizeObserver(() => Blockly.svgResize(workspaceRef.current));
                observer.observe(blocklyDiv.current);
                return () => observer.disconnect();

            }, [isLibrariesLoaded, initScene]);

            // --- ç›£è½é—œå¡è®ŠåŒ– ---
            useEffect(() => {
                if (isLibrariesLoaded) {
                    buildLevel(currentLevel);
                }
            }, [currentLevel, isLibrariesLoaded, buildLevel]);

            // --- åŸ·è¡Œé‚è¼¯ ---
            const runCode = async () => {
                if (gameState === 'RUNNING') return;
                
                registerBlocklyDefinitions(); 
                if (!window.Blockly || !window.Blockly.JavaScript) {
                    alert("Blockly å°šæœªè¼‰å…¥å®Œæˆ"); return;
                }

                setGameState('RUNNING');
                setFailReason('');
                
                const data = levelData.current;
                const offX = -(data.map[0].length)/2;
                const offZ = -(data.map.length)/2;
                playerState.current = { ...data.start };
                updatePlayerTransform(data.start.x, data.start.z, data.start.dir, offX, offZ);
                setCollectedSymbols([]);
                itemsRef.current.forEach(i => { 
                    i.mesh.visible = true; 
                    i.shadow.visible = true; // é¡¯ç¤ºé™°å½±
                    i.collected = false; 
                    i.mesh.material.color.setHex(0xffffff); 
                });

                let code = '';
                try {
                    window.Blockly.JavaScript.init(workspaceRef.current);
                    code = window.Blockly.JavaScript.workspaceToCode(workspaceRef.current);
                } catch (e) {
                    setFailReason("ç¨‹å¼ç¢¼éŒ¯èª¤ï¼š" + e.message);
                    setGameState('FAIL');
                    return;
                }

                const commands = [];
                try {
                    new Function('commands', code)(commands);
                } catch (e) {
                    setGameState('FAIL');
                    return;
                }

                let currentCollected = [];
                for (let cmd of commands) {
                    if (!mountRef.current) break;
                    let { x, z, dir } = playerState.current;
                    let fail = false;

                    if (cmd === 'LEFT') {
                        dir = (dir + 3) % 4; playerState.current.dir = dir;
                        await animateTurn(Math.PI / 2);
                    } else if (cmd === 'RIGHT') {
                        dir = (dir + 1) % 4; playerState.current.dir = dir;
                        await animateTurn(-Math.PI / 2);
                    } else if (cmd === 'MOVE') {
                        let nx = x, nz = z;
                        if (dir === 0) nz -= 1; if (dir === 1) nx += 1; if (dir === 2) nz += 1; if (dir === 3) nx -= 1;

                        if (nz >= 0 && nz < data.map.length && nx >= 0 && nx < data.map[0].length && data.map[nz][nx] !== 0) {
                            playerState.current.x = nx; playerState.current.z = nz;
                            await animateMove(nx, nz, offX, offZ);
                            
                            const idx = itemsRef.current.findIndex(i => i.gridX === nx && i.gridZ === nz && !i.collected);
                            if (idx !== -1) {
                                const item = itemsRef.current[idx];
                                const expected = data.targetZhuyin[currentCollected.length];
                                if (item.symbol === expected) {
                                    item.mesh.visible = false; 
                                    item.shadow.visible = false; // éš±è—é™°å½±
                                    item.collected = true;
                                    currentCollected.push(item.symbol);
                                    setCollectedSymbols([...currentCollected]);
                                } else {
                                    setFailReason(`é †åºéŒ¯èª¤ï¼æ‡‰å…ˆæ”¶é›†ã€Œ${expected}ã€ï¼Œä½†ä½ ç¢°åˆ°äº†ã€Œ${item.symbol}ã€ã€‚`);
                                    item.mesh.material.color.setHex(0xFF0000);
                                    fail = true;
                                }
                            }
                        } else {
                            setFailReason("æ’ç‰†äº†ï¼");
                            await animateBump();
                            fail = true;
                        }
                    }
                    if (fail) { setGameState('FAIL'); return; }
                    await new Promise(r => setTimeout(r, 200));
                }

                if (currentCollected.length === data.targetZhuyin.length) {
                    setGameState('SUCCESS');
                } else {
                    if (gameState !== 'FAIL') { setFailReason("å°šæœªæ”¶é›†å®Œæ‰€æœ‰æ³¨éŸ³ï¼"); setGameState('FAIL'); }
                }
            };

            const animateTurn = (delta) => new Promise(res => {
                const start = playerRef.current.rotation.y, target = start + delta;
                let p = 0;
                const tick = () => {
                    p++; playerRef.current.rotation.y = start + delta * (p/20);
                    if(p<20) requestAnimationFrame(tick); else { playerRef.current.rotation.y = target; res(); }
                }; tick();
            });

            const animateMove = (nx, nz, offX, offZ) => new Promise(res => {
                const startX = playerRef.current.position.x, startZ = playerRef.current.position.z;
                const targetX = (nx * 1) + offX, targetZ = (nz * 1) + offZ;
                let p = 0;
                const tick = () => {
                    p++; const t = p/30;
                    playerRef.current.position.x = startX + (targetX - startX) * t;
                    playerRef.current.position.z = startZ + (targetZ - startZ) * t;
                    playerRef.current.position.y = Math.sin(t * Math.PI) * 0.5;
                    const ang = Math.sin(t * Math.PI * 2) * 0.5;
                    const { armL, armR, legL, legR } = playerLimbsRef.current;
                    if(armL) armL.rotation.x = ang; if(armR) armR.rotation.x = -ang;
                    if(legL) legL.rotation.x = -ang; if(legR) legR.rotation.x = ang;

                    if(p<30) requestAnimationFrame(tick); else {
                        playerRef.current.position.set(targetX, 0, targetZ);
                        Object.values(playerLimbsRef.current).forEach(l => l.rotation.x = 0);
                        res();
                    }
                }; tick();
            });

            const animateBump = () => new Promise(res => {
                let p = 0;
                const tick = () => {
                    p++; playerRef.current.rotation.z = Math.sin(p) * 0.1;
                    if(p<20) requestAnimationFrame(tick); else { playerRef.current.rotation.z = 0; res(); }
                }; tick();
            });

            const currentData = LEVELS_DATA[currentLevel];

            return (
                <div className="flex w-full h-full">
                    {/* å·¦å´ï¼šç¨‹å¼å€ (25%) - å›å¾©åˆ°ç°¡å–®çš„å·¦å´é…ç½® */}
                    <div className="w-1/4 min-w-[280px] flex flex-col border-r border-gray-700 bg-gray-100">
                        <div className="bg-gray-200 px-4 py-2 text-sm font-bold text-gray-700 flex items-center gap-2 border-b border-gray-300">
                            <IconCode /> ç¨‹å¼ç©æœ¨å€
                        </div>
                        <div className="flex-1 relative">
                            <div ref={blocklyDiv} className="absolute inset-0" />
                            {!isLibrariesLoaded && <div className="absolute inset-0 flex items-center justify-center bg-white/80 z-20 text-black font-bold">è³‡æºè¼‰å…¥ä¸­...</div>}
                        </div>
                    </div>

                    {/* å³å´ï¼šéŠæˆ²å€ (75%) */}
                    <div className="flex-1 flex flex-col bg-gray-900 relative">
                        <header className="bg-emerald-600 p-4 shadow-lg flex justify-between items-center z-10">
                            <div className="flex items-center gap-4">
                                <div className="bg-white text-emerald-700 w-12 h-12 flex items-center justify-center rounded-lg font-bold text-3xl shadow">
                                    {currentData.targetChar}
                                </div>
                                <div>
                                    <h1 className="text-xl font-bold">æ³¨éŸ³å¤§å†’éšª</h1>
                                    <div className="flex gap-1 mt-1">
                                        {currentData.targetZhuyin.map((c, i) => (
                                            <span key={i} className={`w-8 h-8 flex items-center justify-center rounded border-2 font-bold text-lg ${collectedSymbols.length > i ? 'bg-yellow-400 text-black border-yellow-500' : 'bg-black/20 text-white/30 border-white/20'}`}>{c}</span>
                                        ))}
                                    </div>
                                </div>
                            </div>
                            <div className="flex items-center gap-2">
                                <span className="bg-black/20 px-3 py-1 rounded text-sm text-white/80">é—œå¡ {currentLevel + 1}/{LEVELS_DATA.length}</span>
                                <button onClick={runCode} disabled={gameState === 'RUNNING' || !isLibrariesLoaded} className={`flex items-center gap-2 px-6 py-2 rounded-lg font-bold shadow transition-transform active:scale-95 ${gameState === 'RUNNING' ? 'bg-gray-500' : 'bg-orange-500 hover:bg-orange-600'}`}>
                                    <IconPlay /> {gameState === 'RUNNING' ? 'åŸ·è¡Œä¸­...' : 'é–‹å§‹æ‹¼éŸ³'}
                                </button>
                            </div>
                        </header>

                        <canvas ref={canvasRef} className="flex-1 block w-full outline-none" />

                        {gameState === 'IDLE' && (
                            <div className="absolute bottom-4 right-4 bg-black/60 p-4 rounded-lg text-right pointer-events-none backdrop-blur-sm">
                                <p className="text-gray-300 text-sm mb-1">ç›®æ¨™ï¼šä¾ç…§é †åºæ”¶é›†</p>
                                <div className="flex justify-end gap-2">
                                    {currentData.targetZhuyin.map((z, i) => <span key={i} className="text-yellow-400 font-bold text-xl">{z}</span>)}
                                </div>
                            </div>
                        )}

                        {gameState === 'SUCCESS' && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20">
                                <IconCheck />
                                <h2 className="text-4xl font-bold text-white mt-4 mb-2">æ‹¼éŸ³æˆåŠŸï¼</h2>
                                <p className="text-gray-300 mb-8">å¤ªæ£’äº†ï¼ä½ å®Œæˆäº†ã€Œ{currentData.targetChar}ã€çš„æ‹¼éŸ³ã€‚</p>
                                {currentLevel < LEVELS_DATA.length - 1 ? (
                                    <button onClick={() => { setCurrentLevel(c => c+1); setGameState('IDLE'); }} className="bg-green-600 hover:bg-green-500 text-white px-8 py-3 rounded-xl font-bold text-xl shadow-lg">ä¸‹ä¸€é—œ âœ</button>
                                ) : (
                                    <div className="text-yellow-400 text-2xl font-bold">ğŸ‰ å…¨æ•¸é€šé—œï¼å¤ªå²å®³äº†ï¼</div>
                                )}
                            </div>
                        )}

                        {gameState === 'FAIL' && (
                            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20">
                                <div className="bg-gray-800 p-8 rounded-2xl border-2 border-red-500 text-center max-w-md shadow-2xl">
                                    <div className="flex justify-center mb-4"><IconAlert /></div>
                                    <h3 className="text-2xl font-bold text-white mb-2">å¤±æ•—äº†...</h3>
                                    <p className="text-red-300 mb-6 text-lg">{failReason}</p>
                                    <button onClick={() => { setGameState('IDLE'); buildLevel(currentLevel); }} className="bg-white/10 hover:bg-white/20 text-white px-6 py-2 rounded-lg flex items-center gap-2 mx-auto">
                                        <IconRotate /> å†è©¦ä¸€æ¬¡
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ZhuyinGame />);
    </script>
</body>
</html>
