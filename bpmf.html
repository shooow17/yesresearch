import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Play, RotateCcw, Box, CheckCircle, AlertTriangle, BookOpen } from 'lucide-react';

// æ³¨éŸ³ç¬¦è™Ÿç¨‹å¼å†’éšª - å²å¸å¤«ç‰ˆ (ä¿®å¾©ç”¢ç”Ÿå™¨éŒ¯èª¤ + å·¦å³åˆ†å‰² 1:2)
// 1. Three.js: ç¹ªè£½ Voxel ä¸–ç•Œèˆ‡æ³¨éŸ³ç¬¦è™Ÿ
// 2. Blockly: æ‹–æ›³ç©æœ¨æ§åˆ¶å²å¸å¤«
// 3. Logic: é †åºè’é›†æ©Ÿåˆ¶

const ZhuyinGame = () => {
  const [isLibrariesLoaded, setIsLibrariesLoaded] = useState(false);
  const [gameState, setGameState] = useState('IDLE'); // IDLE, RUNNING, SUCCESS, FAIL
  const [failReason, setFailReason] = useState('');
  const [currentLevel, setCurrentLevel] = useState(0);
  const [collectedSymbols, setCollectedSymbols] = useState([]); // Array of strings
  const [consoleLog, setConsoleLog] = useState([]);
  
  // Refs
  const blocklyDiv = useRef(null);
  const workspaceRef = useRef(null);
  const canvasRef = useRef(null);
  const mountRef = useRef(null);
  
  // 3D Engine Refs
  const sceneRef = useRef(null);
  const playerRef = useRef(null); 
  const playerLimbsRef = useRef({ armL: null, armR: null, legL: null, legR: null });
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const itemsRef = useRef([]); // Array of symbol meshes
  
  // Game State Refs
  const playerState = useRef({ x: 0, z: 0, dir: 0 }); 
  const levelData = useRef(null);

  // --- Github Pages Encoding Fix ---
  useEffect(() => {
    let metaCharset = document.querySelector("meta[charset]");
    if (!metaCharset) {
        metaCharset = document.createElement("meta");
        metaCharset.setAttribute("charset", "utf-8");
        document.head.insertBefore(metaCharset, document.head.firstChild);
    }
    document.title = "æ³¨éŸ³ç¬¦è™Ÿå¤§å†’éšª - Minecraft Coding";
  }, []);

  // --- Helper: Register Generators (é—œéµä¿®å¾©ï¼šç¨ç«‹æˆå‡½å¼ä»¥ä¾¿é‡è¤‡å‘¼å«) ---
  const registerGenerators = useCallback(() => {
    if (window.Blockly && window.Blockly.JavaScript) {
        window.Blockly.JavaScript['mc_move'] = function(block) {
            return 'commands.push("MOVE");\n';
        };
        window.Blockly.JavaScript['mc_turn_left'] = function(block) {
            return 'commands.push("LEFT");\n';
        };
        window.Blockly.JavaScript['mc_turn_right'] = function(block) {
            return 'commands.push("RIGHT");\n';
        };
    }
  }, []);

  // --- Level Design (9x9 Solid Grid) ---
  const levels = [
    {
      targetChar: "é †",
      targetZhuyin: ["ã„•", "ã„¨", "ã„£", "Ë‹"],
      map: [
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 10, 1, 1, 1, 1], // ã„•
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 11, 1, 1, 1, 1, 1, 12, 1], // ã„¨, (Start), ã„£
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 13, 1, 1, 1, 1], // Ë‹
        [1, 1, 1, 1, 1, 1, 1, 1, 1]
      ],
      itemMapping: { 10: "ã„•", 11: "ã„¨", 12: "ã„£", 13: "Ë‹" },
      start: { x: 4, z: 4, dir: 0 }, // Center
    },
    {
      targetChar: "å­¸",
      targetZhuyin: ["ã„’", "ã„©", "ã„", "ËŠ"],
      map: [
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 13, 1, 1, 1, 1, 1, 12, 1], // ËŠ, ã„
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 10, 1, 1, 1, 1, 1, 11, 1], // ã„’, ã„©
        [1, 1, 1, 1, 1, 1, 1, 1, 1]
      ],
      itemMapping: { 10: "ã„’", 11: "ã„©", 12: "ã„", 13: "ËŠ" },
      start: { x: 4, z: 4, dir: 2 }, 
    }
  ];

  // --- 1. Library Loader ---
  const loadScript = (src) => {
    return new Promise((resolve, reject) => {
      if (document.querySelector(`script[src="${src}"]`)) {
        resolve(); return;
      }
      const script = document.createElement('script');
      script.src = src;
      script.crossOrigin = "anonymous";
      script.onload = resolve;
      script.onerror = () => reject(new Error(`Failed to load ${src}`));
      document.head.appendChild(script);
    });
  };

  useEffect(() => {
    const loadDependencies = async () => {
      try {
        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js');
        await loadScript('https://unpkg.com/blockly@9.3.3/blockly_compressed.js');
        await loadScript('https://unpkg.com/blockly@9.3.3/blocks_compressed.js');
        await loadScript('https://unpkg.com/blockly@9.3.3/javascript_compressed.js');
        await loadScript('https://unpkg.com/blockly@9.3.3/msg/zh-hant.js');
        
        await new Promise(r => setTimeout(r, 500)); 
        setIsLibrariesLoaded(true);
      } catch (error) {
        console.error(error);
        setConsoleLog(prev => [...prev, "è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šã€‚"]);
      }
    };
    loadDependencies();
  }, []);

  // --- 2. Initialize 3D Minecraft Scene ---
  const initScene = useCallback(() => {
    if (!canvasRef.current || !window.THREE) return;
    const THREE = window.THREE;

    const width = canvasRef.current.clientWidth;
    const height = canvasRef.current.clientHeight;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); 
    scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

    const camera = new THREE.PerspectiveCamera(40, width / height, 0.1, 100);
    camera.position.set(0, 20, 12); 
    camera.lookAt(0, 0, 1);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ canvas: canvasRef.current, antialias: true, alpha: false });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    rendererRef.current = renderer;

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(20, 30, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.left = -15;
    dirLight.shadow.camera.right = 15;
    dirLight.shadow.camera.top = 15;
    dirLight.shadow.camera.bottom = -15;
    scene.add(dirLight);

    sceneRef.current = scene;

    const animate = () => {
        if (!mountRef.current) return;
        requestAnimationFrame(animate);
        
        itemsRef.current.forEach((item, idx) => {
            if (item.mesh.visible) {
                item.mesh.position.y = 1.3 + Math.sin(Date.now() * 0.003 + idx) * 0.1;
            }
        });

        renderer.render(scene, camera);
    };
    mountRef.current = true;
    animate();

  }, []);

  // --- Helper: Build Voxel ---
  const createVoxel = (color, x, y, z, sx, sy, sz) => {
      const THREE = window.THREE;
      const geo = new THREE.BoxGeometry(sx, sy, sz);
      const mat = new THREE.MeshStandardMaterial({ color });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, y, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
  };

  // --- Helper: Build Multi-Textured Block with Grid Lines ---
  const createMultiVoxel = (topColor, sideColor, bottomColor, x, y, z, sx, sy, sz) => {
    const THREE = window.THREE;
    const geo = new THREE.BoxGeometry(sx, sy, sz);
    const materials = [
        new THREE.MeshStandardMaterial({ color: sideColor }), 
        new THREE.MeshStandardMaterial({ color: sideColor }), 
        new THREE.MeshStandardMaterial({ color: topColor }),  
        new THREE.MeshStandardMaterial({ color: bottomColor }), 
        new THREE.MeshStandardMaterial({ color: sideColor }), 
        new THREE.MeshStandardMaterial({ color: sideColor }) 
    ];
    const mesh = new THREE.Mesh(geo, materials);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    // Add Edges (Grid Lines)
    const edges = new THREE.EdgesGeometry(geo);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true }));
    mesh.add(line);

    return mesh;
  };

  // --- Helper: Create 3D Transparent Symbol (Single Side) ---
  const createZhuyin3D = (char) => {
      const THREE = window.THREE;
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      
      ctx.clearRect(0, 0, 128, 128);
      ctx.font = 'bold 110px "Microsoft JhengHei", "Noto Sans TC", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 10; 
      ctx.strokeText(char, 64, 64);
      ctx.fillStyle = '#00FFFF'; // Cyan Neon
      ctx.fillText(char, 64, 64);
      
      const texture = new THREE.CanvasTexture(canvas);
      const geometry = new THREE.BoxGeometry(1.3, 1.3, 0.05);
      
      const material = new THREE.MeshBasicMaterial({ 
          map: texture,
          transparent: true,
          side: THREE.FrontSide, 
          depthWrite: false 
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      return mesh;
  };

  // --- 3. Build Level & Character ---
  const buildLevel = useCallback((levelIndex) => {
     if (!sceneRef.current || !window.THREE) return;
     const THREE = window.THREE;
     const scene = sceneRef.current;

     while(scene.children.length > 0){ 
        scene.remove(scene.children[0]); 
     }
     
     const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
     scene.add(ambientLight);
     const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
     dirLight.position.set(20, 30, 20);
     dirLight.castShadow = true;
     dirLight.shadow.mapSize.width = 1024;
     dirLight.shadow.mapSize.height = 1024;
     dirLight.shadow.camera.left = -15;
     dirLight.shadow.camera.right = 15;
     dirLight.shadow.camera.top = 15;
     dirLight.shadow.camera.bottom = -15;
     scene.add(dirLight);

     const data = levels[levelIndex];
     levelData.current = JSON.parse(JSON.stringify(data)); 
     
     playerState.current = { ...data.start };
     setCollectedSymbols([]);
     setFailReason('');

     itemsRef.current = [];
     const mapGroup = new THREE.Group();
     
     const offsetX = -(data.map[0].length * 1) / 2;
     const offsetZ = -(data.map.length * 1) / 2;

     data.map.forEach((row, z) => {
        row.forEach((cell, x) => {
            const posX = (x * 1) + offsetX;
            const posZ = (z * 1) + offsetZ;
            
            if (cell > 0) {
                const grassColor = 0x4C9131;
                const dirtColor = 0x724C30;
                const grassBlock = createMultiVoxel(grassColor, dirtColor, dirtColor, posX, -0.5, posZ, 1, 1, 1);
                mapGroup.add(grassBlock);
            }

            if (data.itemMapping && data.itemMapping[cell]) {
                const symbolChar = data.itemMapping[cell];
                const symbolMesh = createZhuyin3D(symbolChar);
                symbolMesh.position.set(posX, 1.3, posZ); 
                symbolMesh.rotation.x = -Math.PI / 2.5; 
                scene.add(symbolMesh);
                itemsRef.current.push({
                    mesh: symbolMesh,
                    symbol: symbolChar,
                    gridX: x,
                    gridZ: z,
                    collected: false
                });
            }
        });
     });
     scene.add(mapGroup);

     // Build Steve
     const steveGroup = new THREE.Group();
     const skinColor = 0xCF9E7A;
     const hairColor = 0x3A2208;
     
     // Head
     const headGroup = new THREE.Group();
     headGroup.position.y = 1.5;
     headGroup.add(createVoxel(skinColor, 0, 0, 0, 0.4, 0.4, 0.4)); 
     headGroup.add(createVoxel(hairColor, 0, 0.21, 0, 0.42, 0.05, 0.42)); 
     headGroup.add(createVoxel(hairColor, 0, 0.1, -0.21, 0.42, 0.2, 0.05)); 
     headGroup.add(createVoxel(hairColor, -0.21, 0.1, 0, 0.05, 0.2, 0.4)); 
     headGroup.add(createVoxel(hairColor, 0.21, 0.1, 0, 0.05, 0.2, 0.4)); 

     // Face
     const faceZ = 0.205;
     headGroup.add(createVoxel(0xFFFFFF, 0.1, 0.05, faceZ, 0.1, 0.05, 0.02)); 
     headGroup.add(createVoxel(0x2222FF, 0.12, 0.05, faceZ + 0.001, 0.05, 0.05, 0.02)); 
     headGroup.add(createVoxel(0xFFFFFF, -0.1, 0.05, faceZ, 0.1, 0.05, 0.02)); 
     headGroup.add(createVoxel(0x2222FF, -0.12, 0.05, faceZ + 0.001, 0.05, 0.05, 0.02)); 
     headGroup.add(createVoxel(0xB87E6A, 0, -0.05, faceZ, 0.08, 0.05, 0.02)); 
     headGroup.add(createVoxel(0x9E6A4A, 0, -0.12, faceZ, 0.2, 0.06, 0.02)); 

     steveGroup.add(headGroup);

     // Body
     steveGroup.add(createVoxel(0x009999, 0, 0.9, 0, 0.4, 0.6, 0.2)); 
     
     // Limbs
     const leftArm = new THREE.Group();
     leftArm.position.set(-0.3, 1.1, 0); 
     leftArm.add(createVoxel(skinColor, 0, -0.2, 0, 0.18, 0.6, 0.18)); 
     steveGroup.add(leftArm);
     playerLimbsRef.current.armL = leftArm;

     const rightArm = new THREE.Group();
     rightArm.position.set(0.3, 1.1, 0); 
     rightArm.add(createVoxel(skinColor, 0, -0.2, 0, 0.18, 0.6, 0.18));
     steveGroup.add(rightArm);
     playerLimbsRef.current.armR = rightArm;

     const leftLeg = new THREE.Group();
     leftLeg.position.set(-0.1, 0.6, 0); 
     leftLeg.add(createVoxel(0x0000AA, 0, -0.3, 0, 0.18, 0.6, 0.18));
     steveGroup.add(leftLeg);
     playerLimbsRef.current.legL = leftLeg;

     const rightLeg = new THREE.Group();
     rightLeg.position.set(0.1, 0.6, 0); 
     rightLeg.add(createVoxel(0x0000AA, 0, -0.3, 0, 0.18, 0.6, 0.18));
     steveGroup.add(rightLeg);
     playerLimbsRef.current.legR = rightLeg;

     scene.add(steveGroup);
     playerRef.current = steveGroup;

     // Initial Transform
     const rots = [Math.PI, Math.PI/2, 0, -Math.PI/2]; 
     updatePlayerTransform(data.start.x, data.start.z, data.start.dir, offsetX, offsetZ, rots);

  }, []);

  const updatePlayerTransform = (gridX, gridZ, dirIndex, offX, offZ, rots) => {
      if (!playerRef.current) return;
      playerRef.current.position.x = (gridX * 1) + offX;
      playerRef.current.position.z = (gridZ * 1) + offZ;
      if (rots) {
          playerRef.current.rotation.y = rots[dirIndex];
      }
      if(playerLimbsRef.current.armL) playerLimbsRef.current.armL.rotation.x = 0;
      if(playerLimbsRef.current.armR) playerLimbsRef.current.armR.rotation.x = 0;
      if(playerLimbsRef.current.legL) playerLimbsRef.current.legL.rotation.x = 0;
      if(playerLimbsRef.current.legR) playerLimbsRef.current.legR.rotation.x = 0;
  };

  // --- 4. Blockly Setup ---
  useEffect(() => {
    if (!isLibrariesLoaded || !blocklyDiv.current) return;
    
    if (!window.Blockly || !window.Blockly.JavaScript) {
        return;
    }

    initScene();
    buildLevel(0);
    // é¦–æ¬¡è¼‰å…¥ä¹Ÿè¨»å†Šä¸€æ¬¡ç”¢ç”Ÿå™¨
    registerGenerators();

    const Blockly = window.Blockly;

    // Define Blocks
    if (!Blockly.Blocks['mc_move']) {
        Blockly.Blocks['mc_move'] = {
            init: function() {
              this.appendDummyInput().appendField("å‰é€²ä¸€æ ¼");
              this.setPreviousStatement(true, null);
              this.setNextStatement(true, null);
              this.setColour(160);
            }
        };
    }
    if (!Blockly.Blocks['mc_turn_left']) {
        Blockly.Blocks['mc_turn_left'] = {
            init: function() {
              this.appendDummyInput().appendField("å·¦è½‰ â†º");
              this.setPreviousStatement(true, null);
              this.setNextStatement(true, null);
              this.setColour(160);
            }
        };
    }
    if (!Blockly.Blocks['mc_turn_right']) {
        Blockly.Blocks['mc_turn_right'] = {
            init: function() {
              this.appendDummyInput().appendField("å³è½‰ â†»");
              this.setPreviousStatement(true, null);
              this.setNextStatement(true, null);
              this.setColour(160);
            }
        };
    }

    // Inject Workspace
    if (workspaceRef.current) workspaceRef.current.dispose();
    
    workspaceRef.current = Blockly.inject(blocklyDiv.current, {
        toolbox: `
        <xml>
            <block type="mc_move"></block>
            <block type="mc_turn_left"></block>
            <block type="mc_turn_right"></block>
            <block type="controls_repeat_ext">
                <value name="TIMES">
                    <shadow type="math_number">
                        <field name="NUM">4</field>
                    </shadow>
                </value>
            </block>
        </xml>`,
        scrollbars: true,
        trashcan: true,
        zoom: { 
            controls: true,
            wheel: true,
            startScale: 1.0, 
            maxScale: 3, 
            minScale: 0.8, 
            scaleSpeed: 1.2 
        },
        theme: {
            'componentStyles': {
                'workspaceBackgroundColour': '#f0f0f0',
                'toolboxBackgroundColour': '#dedede'
            }
        }
    });
    
    const resizeObserver = new ResizeObserver(() => {
        Blockly.svgResize(workspaceRef.current);
    });
    resizeObserver.observe(blocklyDiv.current);

    return () => {
        if (workspaceRef.current) workspaceRef.current.dispose();
        resizeObserver.disconnect();
    }
  }, [isLibrariesLoaded, initScene, buildLevel, registerGenerators]);


  // --- 5. Game Logic Interpreter ---
  const runCode = async () => {
    if (gameState === 'RUNNING') return;

    // --- CRITICAL FIX: Force Generator Registration before run ---
    // è§£æ±º "JavaScript generator does not know how to generate code" éŒ¯èª¤
    registerGenerators();
    
    if (!window.Blockly || !window.Blockly.JavaScript) {
        setConsoleLog(prev => ["éŒ¯èª¤: ç¨‹å¼ç¢¼ç”¢ç”Ÿå™¨æœªåˆå§‹åŒ–ã€‚", ...prev]);
        return;
    }

    setGameState('RUNNING');
    setFailReason('');
    setConsoleLog(['> é–‹å§‹åŸ·è¡Œ...']);
    
    // Reset state
    const data = levelData.current;
    const offX = -(data.map[0].length)/2;
    const offZ = -(data.map.length)/2;
    playerState.current = { ...data.start };
    
    const initRots = [Math.PI, Math.PI/2, 0, -Math.PI/2];
    updatePlayerTransform(data.start.x, data.start.z, data.start.dir, offX, offZ, initRots);
    
    setCollectedSymbols([]);
    // Visual reset
    itemsRef.current.forEach(i => {
        i.mesh.visible = true;
        i.collected = false;
        i.mesh.material.color.setHex(0xffffff); // Reset color
    });

    let code = '';
    try {
        window.Blockly.JavaScript.init(workspaceRef.current);
        code = window.Blockly.JavaScript.workspaceToCode(workspaceRef.current);
    } catch (e) {
        console.error("Generators failed:", e);
        setFailReason(`ç”¢ç”Ÿç¨‹å¼ç¢¼éŒ¯èª¤: ${e.message}`);
        setGameState('FAIL');
        return;
    }
    
    const commands = [];
    try {
        // eslint-disable-next-line no-new-func
        new Function('commands', code)(commands);
    } catch (e) {
        setGameState('FAIL');
        return;
    }

    // --- Execution Loop ---
    let currentCollected = [];

    for (let cmd of commands) {
        if (!mountRef.current) break; 

        let { x, z, dir } = playerState.current;
        let fail = false;

        if (cmd === 'LEFT') {
            dir = (dir + 3) % 4; 
            playerState.current.dir = dir;
            await animateTurn(Math.PI / 2);
        } else if (cmd === 'RIGHT') {
            dir = (dir + 1) % 4;
            playerState.current.dir = dir;
            await animateTurn(-Math.PI / 2);
        } else if (cmd === 'MOVE') {
            let nx = x;
            let nz = z;
            if (dir === 0) nz -= 1; // North
            if (dir === 1) nx += 1; // East
            if (dir === 2) nz += 1; // South
            if (dir === 3) nx -= 1; // West

            // Check walls
            if (nz >= 0 && nz < data.map.length && nx >= 0 && nx < data.map[0].length && data.map[nz][nx] !== 0) {
                playerState.current.x = nx;
                playerState.current.z = nz;
                await animateMove(nx, nz, offX, offZ);
                
                // Check Item Collection
                const itemIndex = itemsRef.current.findIndex(i => i.gridX === nx && i.gridZ === nz && !i.collected);
                
                if (itemIndex !== -1) {
                    const item = itemsRef.current[itemIndex];
                    
                    // Logic Check
                    const expectedSymbol = data.targetZhuyin[currentCollected.length];
                    
                    if (item.symbol === expectedSymbol) {
                        // Correct!
                        item.mesh.visible = false;
                        item.collected = true;
                        currentCollected.push(item.symbol);
                        setCollectedSymbols([...currentCollected]); 
                        
                    } else {
                        // Wrong Symbol!
                        setFailReason(`é †åºéŒ¯èª¤ï¼ä½ éœ€è¦å…ˆè’é›†ã€Œ${expectedSymbol}ã€ï¼Œä½†ä½ æ‹¿åˆ°äº†ã€Œ${item.symbol}ã€ã€‚`);
                        item.mesh.material.color.setHex(0xFF0000); 
                        fail = true;
                    }
                }

            } else {
                setFailReason("æ’åˆ°ç‰†å£äº†ï¼");
                await animateBump(); 
                fail = true;
            }
        }
        
        if (fail) {
            setGameState('FAIL');
            return;
        }

        await new Promise(r => setTimeout(r, 200)); 
    }

    // Check Win
    if (currentCollected.length === data.targetZhuyin.length) {
        setGameState('SUCCESS');
    } else {
        if (gameState !== 'FAIL') {
             setFailReason("å°šæœªè’é›†å®Œæ‰€æœ‰æ³¨éŸ³ç¬¦è™Ÿï¼");
             setGameState('FAIL');
        }
    }
  };

  // --- Animations ---
  const animateTurn = (angleDelta) => {
      return new Promise(resolve => {
          const startRot = playerRef.current.rotation.y;
          const targetRot = startRot + angleDelta;
          let progress = 0; const duration = 20; 
          const tick = () => {
              progress++; const t = progress/duration;
              playerRef.current.rotation.y = startRot + (angleDelta) * t;
              if (progress < duration) requestAnimationFrame(tick);
              else { playerRef.current.rotation.y = targetRot; resolve(); }
          };
          tick();
      });
  };

  const animateMove = (nx, nz, offX, offZ) => {
    return new Promise(resolve => {
        const startX = playerRef.current.position.x;
        const startZ = playerRef.current.position.z;
        const targetX = (nx * 1) + offX;
        const targetZ = (nz * 1) + offZ;
        const { armL, armR, legL, legR } = playerLimbsRef.current;
        let progress = 0; const duration = 30; 
        const tick = () => {
            progress++; const t = progress / duration;
            const yOffset = Math.sin(t * Math.PI) * 0.5; 
            playerRef.current.position.x = startX + (targetX - startX) * t;
            playerRef.current.position.z = startZ + (targetZ - startZ) * t;
            playerRef.current.position.y = yOffset; 
            // Limbs
            const limbAngle = Math.sin(t * Math.PI * 2) * 0.5; 
            if(armL) armL.rotation.x = limbAngle; if(armR) armR.rotation.x = -limbAngle;
            if(legL) legL.rotation.x = -limbAngle; if(legR) legR.rotation.x = limbAngle;
            
            if (progress < duration) requestAnimationFrame(tick);
            else {
                playerRef.current.position.set(targetX, 0, targetZ);
                if(armL) armL.rotation.x = 0; if(armR) armR.rotation.x = 0;
                if(legL) legL.rotation.x = 0; if(legR) legR.rotation.x = 0;
                resolve();
            }
        };
        tick();
    });
  };

  const animateBump = () => {
      return new Promise(resolve => {
          let progress = 0; const duration = 20;
          const tick = () => {
              progress++;
              playerRef.current.rotation.z = Math.sin(progress) * 0.1;
              if (progress < duration) requestAnimationFrame(tick);
              else { playerRef.current.rotation.z = 0; resolve(); }
          };
          tick();
      });
  };

  const nextLevel = () => {
      if (currentLevel < levels.length - 1) {
          const next = currentLevel + 1;
          setCurrentLevel(next);
          buildLevel(next);
          setGameState('IDLE');
          setConsoleLog([]);
          workspaceRef.current.clear();
      }
  };

  const currentLevelData = levels[currentLevel];

  return (
    <div className="flex flex-col h-screen bg-neutral-900 text-white font-sans overflow-hidden">
      {/* Header - Educational Style */}
      <header className="bg-emerald-600 p-4 shadow-lg flex justify-between items-center z-10 h-16 shrink-0">
        <div className="flex items-center gap-4">
           <div className="bg-white text-emerald-700 p-1 rounded-lg font-serif font-bold text-2xl w-10 h-10 flex items-center justify-center shadow-inner">
             {currentLevelData.targetChar}
           </div>
           <div>
             <h1 className="text-lg font-bold tracking-wide">æ³¨éŸ³ç¬¦è™Ÿå¤§å†’éšª</h1>
             <div className="flex gap-1 mt-0.5">
                {currentLevelData.targetZhuyin.map((char, i) => {
                    const isCollected = collectedSymbols.length > i;
                    return (
                        <span key={i} className={`
                            w-6 h-6 flex items-center justify-center rounded font-mono text-sm font-bold border
                            ${isCollected 
                                ? 'bg-yellow-400 text-black border-yellow-500 scale-110' 
                                : 'bg-black/20 text-white/50 border-white/20'}
                        `}>
                            {char}
                        </span>
                    );
                })}
             </div>
           </div>
        </div>
        
        <div className="flex items-center gap-2">
             <div className="text-xs bg-black/20 px-2 py-1 rounded">
                Level {currentLevel + 1}
             </div>
            <button 
                onClick={runCode}
                disabled={gameState === 'RUNNING' || !isLibrariesLoaded}
                className={`flex items-center gap-2 px-4 py-1.5 rounded-lg font-bold shadow-lg text-sm transition-all ${
                    gameState === 'RUNNING' ? 'bg-gray-500 cursor-not-allowed' : 'bg-orange-500 hover:bg-orange-600 hover:scale-105'
                }`}
            >
                {gameState === 'RUNNING' ? 'æ‹¼éŸ³ä¸­...' : <><Play size={16} fill="currentColor" /> é–‹å§‹</>}
            </button>
        </div>
      </header>

      {/* Main Area (Horizontal Split) */}
      <div className="flex flex-1 overflow-hidden">
         
         {/* Left: Blockly Editor (1/3) */}
         <div className="w-1/3 min-w-[320px] relative border-r border-gray-700 bg-gray-100">
            <div ref={blocklyDiv} className="absolute inset-0" />
            {!isLibrariesLoaded && (
                <div className="absolute inset-0 flex items-center justify-center bg-white/80 z-20 text-black">
                    è¼‰å…¥è³‡æºä¸­...
                </div>
            )}
         </div>

         {/* Right: 3D View (2/3) */}
         <div className="flex-1 flex flex-col bg-gray-900 relative">
            <canvas ref={canvasRef} className="flex-1 block w-full outline-none cursor-move" />
            
            {/* Status Overlays */}
            {gameState === 'SUCCESS' && (
                <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center animate-in fade-in zoom-in p-8 text-center z-20">
                    <CheckCircle className="w-16 h-16 text-green-400 mb-4" />
                    <h2 className="text-3xl font-bold text-white mb-2">{currentLevelData.targetChar}</h2>
                    <p className="text-gray-300 mb-6 text-base">æ‹¼éŸ³æˆåŠŸï¼ä½ çœŸæ£’ï¼</p>
                    
                    {currentLevel < levels.length - 1 ? (
                        <button onClick={nextLevel} className="bg-green-600 hover:bg-green-500 text-white px-6 py-2 rounded-xl font-bold text-lg shadow-lg transform hover:scale-105 transition-all">
                            æŒ‘æˆ°ä¸‹ä¸€å€‹å­— âœ
                        </button>
                    ) : (
                        <div className="text-yellow-400 text-xl font-bold">ğŸ‰ å…¨éƒ¨å­¸æœƒäº†ï¼å¤ªå²å®³äº†ï¼ ğŸ‰</div>
                    )}
                </div>
            )}

            {gameState === 'FAIL' && (
                 <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-red-900/95 p-6 rounded-xl border-2 border-red-500 text-center shadow-2xl w-3/4 max-w-sm z-20">
                    <AlertTriangle className="w-12 h-12 text-red-400 mx-auto mb-2" />
                    <h3 className="text-xl font-bold text-white mb-2">å“å‘€...</h3>
                    <p className="text-red-100 mb-4 text-sm font-medium">{failReason}</p>
                    <button onClick={() => { 
                        setGameState('IDLE'); 
                        buildLevel(currentLevel); 
                    }} className="bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-lg flex items-center gap-2 mx-auto transition-colors">
                        <RotateCcw size={16} /> å†è©¦ä¸€æ¬¡
                    </button>
                 </div>
            )}

            {/* Instruction Overlay */}
            {gameState === 'IDLE' && (
                 <div className="absolute bottom-2 right-2 bg-black/60 p-2 rounded text-right pointer-events-none z-10">
                     <p className="text-gray-300 text-xs">ç›®æ¨™ï¼šä¾ç…§é †åºè’é›†æ³¨éŸ³</p>
                     <div className="flex justify-end gap-1 mt-1">
                        {currentLevelData.targetZhuyin.map((z,i) => (
                            <span key={i} className="text-yellow-400 font-bold text-sm">{z}</span>
                        ))}
                     </div>
                 </div>
            )}
         </div>

      </div>
    </div>
  );
};

export default ZhuyinGame;
